use std::rc::Rc;

use bumpalo::Bump;
use byteorder::{ByteOrder, LittleEndian};

use scarf::analysis::{FuncCallPair, RelocValues};
use scarf::exec_state::{ExecutionState, VirtualAddress};
use scarf::{BinaryFile, BinarySection, MemAccessSize, Operand, OperandCtx};

use crate::ai::{self, AiScriptHook};
use crate::analysis_find::{FunctionFinder};
use crate::bullets;
use crate::campaign;
use crate::clientside;
use crate::commands;
use crate::crt;
use crate::dat::{self, DatTablePtr, DatPatch, DatPatches, DatReplaceFunc};
use crate::dialog;
use crate::eud::{self, EudTable};
use crate::file;
use crate::firegraft::{self, RequirementTables};
use crate::game::{self, Limits};
use crate::game_init;
use crate::iscript::{self, StepIscriptHook};
use crate::images;
use crate::map::{self, RunTriggers, TriggerUnitCountCaches};
use crate::minimap;
use crate::network::{self, SnpDefinitions};
use crate::pathing;
use crate::players;
use crate::renderer::{self, PrismShaders};
use crate::requirements;
use crate::rng;
use crate::save;
use crate::sound;
use crate::step_order::{self, SecondaryOrderHook, StepOrderHiddenHook};
use crate::sprites;
use crate::storm;
use crate::switch::{CompleteSwitch};
use crate::text;
use crate::units;
use crate::vtables::{self, Vtables};
use crate::x86_64_globals;
use crate::x86_64_unwind;

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FiregraftAddresses<Va: VirtualAddress> {
    pub buttonsets: Vec<Va>,
    pub requirement_table_refs: RequirementTables<Va>,
    pub unit_status_funcs: Vec<Va>,
}

#[derive(Clone, Debug)]
pub struct Patch<Va: VirtualAddress> {
    pub address: Va,
    pub data: Vec<u8>,
}

// Just since option spam for caches is a bit hard to keep track of
struct Cached<T: Clone>(Option<T>);

impl<T: Clone> Cached<T> {
    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, fun: F) -> &mut T {
        self.0.get_or_insert_with(fun)
    }

    pub fn cached(&self) -> Option<T> {
        self.0.clone()
    }

    pub fn cache(&mut self, val: &T) {
        self.0 = Some(val.clone());
    }

    pub fn is_none(&self) -> bool {
        self.0.is_none()
    }
}

impl<T: Clone> Default for Cached<T> {
    fn default() -> Cached<T> {
        Cached(None)
    }
}

// Using repr(C) to make sure that the large, less accessed cache is placed last
// in this struct's layout
#[repr(C)]
pub struct Analysis<'e, E: ExecutionState<'e>> {
    shareable: AnalysisCtx<'e, E>,
    cache: AnalysisCache<'e, E>,
}

pub struct AnalysisCtx<'e, E: ExecutionState<'e>> {
    pub binary: &'e BinaryFile<E::VirtualAddress>,
    pub binary_sections: BinarySections<'e, E>,
    pub ctx: scarf::OperandCtx<'e>,
    pub arg_cache: ArgCache<'e, E>,
    pub bump: Bump,
}

pub struct BinarySections<'e, E: ExecutionState<'e>> {
    pub text: &'e BinarySection<E::VirtualAddress>,
    pub data: &'e BinarySection<E::VirtualAddress>,
    pub rdata: &'e BinarySection<E::VirtualAddress>,
}

/// Example:
/// ```ignore
/// results! {
///     // Defines function
///     // `Analysis::address_analysis(AddressAnalysis) -> Option<E::VirtualAddress>`
///     fn address_analysis -> Option<E::VirtualAddress>;
///     // Will be used by print_text implementation below
///     analyze_many_fn = analyze_many_addr;
///     enum AddressAnalysis {
///         // Variant StepObjects is received by calling
///         // `Analysis::step_objects(&mut self) -> Option<E::VirtualAddress>`
///         StepObjects => step_objects,
///         // When given a third name (cache_print_text),
///         // print_text is generated by this macro to be
///         // fn print_text(&mut self) -> Option<E::VirtualAddress> {
///         //     self.analyze_many_addr(
///         //         AddressAnalysis::PrintText,
///         //         AnalysisCache::cache_print_text,
///         //     )
///         // }
///         // (cache_print_text is implemented manually)
///         PrintText => print_text => cache_print_text,
///     }
/// }
/// ```
macro_rules! results {
    (
        fn $analysis_fn_name:ident -> Option<$value_type:ty>;
        analyze_many_fn = $analyze_many_name:ident;
        enum $name:ident {
            $($variant:ident => $variant_name:ident $(=> $cache_fn_name:ident)? ,)*
        }
    ) => {
        #[derive(Copy, Clone, Debug)]
        pub enum $name {
            $($variant,)*
        }

        impl $name {
            const COUNT: usize = $( ($name::$variant, 1).1 + )* 0;
            pub fn name(self) -> &'static str {
                match self {
                    $($name::$variant => stringify!($variant_name),)*
                }
            }

            pub fn iter() -> impl Iterator<Item = $name> {
                static ITEMS: [$name; $name::COUNT] = [
                    $($name::$variant,)*
                ];
                ITEMS.iter().copied()
            }
        }

        impl<'e, E: ExecutionState<'e>> Analysis<'e, E> {
            pub fn $analysis_fn_name(&mut self, input: $name) -> Option<$value_type> {
                let func: fn(&mut Analysis<'e, E>) -> Option<$value_type> = match input {
                    $($name::$variant => Analysis::$variant_name,)*
                };
                func(self)
            }

            $(
                $(
                    pub fn $variant_name(&mut self) -> Option<$value_type> {
                        self.$analyze_many_name($name::$variant, AnalysisCache::$cache_fn_name)
                    }
                )?
            )*
        }
    };
}

results! {
    fn address_analysis -> Option<E::VirtualAddress>;
    analyze_many_fn = analyze_many_addr;
    enum AddressAnalysis {
        StepObjects => step_objects,
        SendCommand => send_command,
        PrintText => print_text => cache_print_text,
        AddToReplayData => add_to_replay_data => cache_print_text,
        StepOrder => step_order,
        PrepareDrawImage => prepare_draw_image => cache_draw_game_layer,
        DrawImage => draw_image => cache_draw_game_layer,
        PlaySmk => play_smk,
        AddOverlayIscript => add_overlay_iscript,
        RunDialog => run_dialog => cache_run_dialog,
        GluCmpgnEventHandler => glucmpgn_event_handler => cache_run_dialog,
        AiUpdateAttackTarget => ai_update_attack_target,
        IsOutsideGameScreen => is_outside_game_screen,
        ChooseSnp => choose_snp => cache_choose_snp,
        GetLocales => get_locales => cache_choose_snp,
        LoadImages => load_images,
        InitGameNetwork => init_game_network,
        SpawnDialog => spawn_dialog => cache_spawn_dialog,
        InitStatLb => init_statlb => cache_spawn_dialog,
        InitStatRes => init_statres => cache_init_statres,
        GetStatResIconsDdsGrp => get_statres_icons_ddsgrp => cache_init_statres,
        // Memory allocation function that at least TTF code uses.
        // (Should be Win32 HeapAlloc with a specific heap)
        TtfMalloc => ttf_malloc,
        DrawGraphicLayers => draw_graphic_layers,
        AiAttackPrepare => ai_attack_prepare => cache_aiscript_switch,
        AiAttackClear => ai_attack_clear => cache_aiscript_switch,
        JoinGame => join_game,
        SnetInitializeProvider => snet_initialize_provider,
        CheckDatRequirements => check_dat_requirements,
        GiveAi => give_ai,
        PlaySound => play_sound,
        AiPrepareMovingTo => ai_prepare_moving_to,
        StepReplayCommands => step_replay_commands,
        AiTrainMilitary => ai_train_military,
        AiAddMilitaryToRegion => ai_add_military_to_region,
        GetRegion => get_region => cache_regions,
        ChangeAiRegionState => change_ai_region_state => cache_regions,
        InitGame => init_game => cache_init_game,
        CreateLoneSprite => create_lone_sprite => cache_sprites,
        CreateUnit => create_unit => cache_unit_creation,
        FinishUnitPre => finish_unit_pre => cache_unit_creation,
        FinishUnitPost => finish_unit_post => cache_unit_creation,
        InitSprites => init_sprites => cache_init_sprites,
        SerializeSprites => serialize_sprites => cache_sprite_serialization,
        DeserializeSprites => deserialize_sprites => cache_sprite_serialization,
        FontCacheRenderAscii => font_cache_render_ascii => cache_font_render,
        TtfCacheCharacter => ttf_cache_character => cache_font_render,
        TtfRenderSdf => ttf_render_sdf => cache_font_render,
        UpdateVisibilityPoint => update_visibility_point => cache_map_tile_flags,
        LayoutDrawText => layout_draw_text => cache_tooltip_related,
        DrawF10MenuTooltip => draw_f10_menu_tooltip => cache_tooltip_related,
        DrawTooltipLayer => draw_tooltip_layer => cache_tooltip_related,
        SelectMapEntry => select_map_entry => cache_select_map_entry,
        CreateBullet => create_bullet => cache_bullet_creation,
        OrderInitArbiter => order_init_arbiter => cache_order_issuing,
        PrepareIssueOrder => prepare_issue_order => cache_order_issuing,
        DoNextQueuedOrder => do_next_queued_order => cache_order_issuing,
        ResetUiEventHandlers => reset_ui_event_handlers => cache_ui_event_handlers,
        ClampZoom => clamp_zoom,
        DrawMinimapUnits => draw_minimap_units,
        InitNetPlayer => init_net_player => cache_net_players,
        ScMain => sc_main => cache_game_init,
        MainMenuEntryHook => mainmenu_entry_hook => cache_game_init,
        GameLoop => game_loop => cache_game_init,
        RunMenus => run_menus => cache_game_init,
        SinglePlayerStart => single_player_start => cache_single_player_start,
        InitUnits => init_units => cache_init_units,
        LoadDat => load_dat => cache_init_units,
        InitStormNetworking => init_storm_networking => cache_init_storm_networking,
        LoadSnpList => load_snp_list => cache_init_storm_networking,
        SetBriefingMusic => set_briefing_music => cache_menu_screens,
        PreMissionGlue => pre_mission_glue => cache_menu_screens,
        ShowMissionGlue => show_mission_glue => cache_menu_screens,
        MenuSwishIn => menu_swish_in => cache_glucmpgn_events,
        MenuSwishOut => menu_swish_out => cache_glucmpgn_events,
        AiSpellCast => ai_spell_cast,
        GiveUnit => give_unit,
        SetUnitPlayer => set_unit_player,
        RemoveFromSelections => remove_from_selections => cache_set_unit_player_fns,
        RemoveFromClientSelection => remove_from_client_selection => cache_set_unit_player_fns,
        ClearBuildQueue => clear_build_queue => cache_set_unit_player_fns,
        UnitChangingPlayer => unit_changing_player => cache_set_unit_player_fns,
        PlayerGainedUpgrade => player_gained_upgrade => cache_set_unit_player_fns,
        UnitApplySpeedUpgrades => unit_apply_speed_upgrades => cache_unit_speed,
        UnitUpdateSpeed => unit_update_speed => cache_unit_speed,
        UnitUpdateSpeedIscript => unit_update_speed_iscript => cache_unit_speed,
        UnitBuffedFlingySpeed => unit_buffed_flingy_speed => cache_unit_speed,
        UnitBuffedAcceleration => unit_buffed_acceleration => cache_unit_speed,
        UnitBuffedTurnSpeed => unit_buffed_turn_speed => cache_unit_speed,
        StartUdpServer => start_udp_server,
        // this = Anim *, a1 use_file_type, a2 file_type, a3 flags
        // this = Anim *, a2 file_type_u64, a3 flags on 64bit
        OpenAnimSingleFile => open_anim_single_file => cache_image_loading,
        // this = Anim *, a1 first_image_id, a2 image_count (0x3e7), a3_4 file_type, a5 flags,
        //      a6 u8 *out?
        // this = Anim *, a2 first_image_id, a3 image_count (0x3e7), a4 file_type_u64, a5 flags,
        //      a6 u8 *out?
        OpenAnimMultiFile => open_anim_multi_file => cache_image_loading,
        InitSkins => init_skins => cache_image_loading,
        AddAssetChangeCallback => add_asset_change_callback => cache_image_loading,
        AnimAssetChangeCb => anim_asset_change_cb => cache_image_loading,
        InitRealTimeLighting => init_real_time_lighting => cache_images_loaded,
        StepActiveUnitFrame => step_active_unit_frame => cache_step_objects,
        StepHiddenUnitFrame => step_hidden_unit_frame => cache_step_objects,
        StepBulletFrame => step_bullet_frame => cache_step_objects,
        StepBullets => step_bullets => cache_step_objects,
        CreepModifyState => creep_modify_state => cache_step_objects,
        ForEachSurroundingile => for_each_surrounding_tile => cache_step_objects,
        CreepUpdateBorderForTile => creep_update_border_for_tile => cache_step_objects,
        GetCreepSpreadArea => get_creep_spread_area => cache_step_objects,
        RevealUnitArea => reveal_unit_area => cache_step_objects,
        UpdateUnitVisibility => update_unit_visibility => cache_step_objects,
        UpdateCloakState => update_cloak_state => cache_step_objects,
        StepUnitMovement => step_unit_movement => cache_step_active_unit,
        InitMapFromPath => init_map_from_path => cache_init_map,
        MapInitChkCallbacks => map_init_chk_callbacks => cache_init_map,
        StepNetwork => step_network => cache_game_loop,
        ReceiveStormTurns => receive_storm_turns => cache_step_network,
        AiStepRegion => ai_step_region => cache_ai_step_frame,
        AiSpendMoney => ai_spend_money => cache_ai_step_frame,
        AiTargetExpansion => ai_target_expansion => cache_ai_step_frame,
        DoAttack => do_attack => cache_do_attack,
        DoAttackMain => do_attack_main => cache_do_attack,
        AiTryReturnHome => ai_try_return_home => cache_do_attack,
        UpdateAttackTarget => update_attack_target => cache_do_attack,
        CheckUnitRequirements => check_unit_requirements => cache_unit_requirements,
        SnetSendPackets => snet_send_packets => cache_snet_handle_packets,
        SnetRecvPackets => snet_recv_packets => cache_snet_handle_packets,
        OpenFile => open_file,
        DrawGameLayer => draw_game_layer,
        RenderScreen => render_screen => cache_game_loop,
        LoadPcx => load_pcx => cache_game_loop,
        SetMusic => set_music => cache_game_loop,
        StepIscript => step_iscript,
        StepIscriptSwitch => step_iscript_switch => cache_step_iscript,
        ProcessCommands => process_commands => cache_step_network,
        ProcessLobbyCommands => process_lobby_commands => cache_step_network,
        StepAiScript => step_ai_script => cache_ai_step_frame,
        StepAiScripts => step_ai_scripts => cache_ai_step_frame,
        StepGameLoop => step_game_loop => cache_game_loop,
        StepGameLogic => step_game_logic => cache_game_loop,
        ProcessEvents => process_events => cache_game_loop,
        StepBnetController => step_bnet_controller => cache_process_events,
        CreateGameMultiplayer => create_game_multiplayer => cache_select_map_entry_children,
        MapEntryLoadMap => map_entry_load_map => cache_select_map_entry_children,
        MapEntryLoadSave => map_entry_load_save => cache_select_map_entry_children,
        MapEntryLoadReplay => map_entry_load_replay => cache_select_map_entry_children,
        GetMouseX => get_mouse_x => cache_mouse_xy,
        GetMouseY => get_mouse_y => cache_mouse_xy,
        AddPylonAura => add_pylon_aura => cache_pylon_aura,
        SinglePlayerMapEnd => single_player_map_end => cache_sp_map_end,
        SetScmainState => set_scmain_state => cache_sp_map_end_analysis,
        UnlockMission => unlock_mission => cache_sp_map_end_analysis,
        CreateFowSprite => create_fow_sprite => cache_update_unit_visibility,
        DuplicateSprite => duplicate_sprite => cache_update_unit_visibility,
        InitStatusScreen => init_status_screen,
        StatusScreenEventHandler => status_screen_event_handler => cache_multi_wireframes,
        NetFormatTurnRate => net_format_turn_rate,
        LoadReplayScenarioChk => load_replay_scenario_chk => cache_init_map_from_path,
        SfileCloseArchive => sfile_close_archive => cache_init_map_from_path,
        OpenMapMpq => open_map_mpq => cache_init_map_from_path,
        // arg 1 void *mpq_handle, arg 2 char *filename, arg 3 u8 *out_ptr arg 4 u32 *out_size,
        // arg 5 extra_out_size (0), arg 6 storm flags (0), arg 7 unk opt ptr? (0); stdcall
        ReadWholeMpqFile => read_whole_mpq_file => cache_init_map_from_path,
        // Takes 8th argument which is unused anyway but affects calling convention
        // so have separate analysis result for it.
        ReadWholeMpqFile2 => read_whole_mpq_file2 => cache_init_map_from_path,
        TargetingLClick => targeting_lclick => cache_ui_event_handlers,
        TargetingRClick => targeting_rclick => cache_ui_event_handlers,
        BuildingPlacementLClick => building_placement_lclick => cache_ui_event_handlers,
        BuildingPlacementRClick => building_placement_rclick => cache_ui_event_handlers,
        // These are active when not targeting / placing building
        GameScreenLClick => game_screen_lclick => cache_ui_event_handlers,
        GameScreenRClick => game_screen_rclick => cache_game_screen_rclick,
        UiDefaultKeyDownHandler => ui_default_key_down_handler => cache_ui_event_handlers,
        UiDefaultKeyUpHandler => ui_default_key_up_handler => cache_ui_event_handlers,
        UiDefaultLeftDownHandler => ui_default_left_down_handler => cache_ui_event_handlers,
        UiDefaultRightDownHandler => ui_default_right_down_handler => cache_ui_event_handlers,
        UiDefaultMiddleDownHandler => ui_default_middle_down_handler => cache_ui_event_handlers,
        UiDefaultMiddleUpHandler => ui_default_middle_up_handler => cache_ui_event_handlers,
        UiDefaultPeriodicHandler => ui_default_periodic_handler => cache_ui_event_handlers,
        UiDefaultCharHandler => ui_default_char_handler => cache_ui_event_handlers,
        UiDefaultScrollHandler => ui_default_scroll_handler => cache_ui_event_handlers,
        StartTargeting => start_targeting => cache_start_targeting,
        FindUnitForClick => find_unit_for_click => cache_targeting_lclick,
        FindFowSpriteForClick => find_fow_sprite_for_click => cache_targeting_lclick,
        HandleTargetedClick => handle_targeted_click => cache_targeting_lclick,
        // this = unit, a1 weapon_id, a2 target
        CheckWeaponTargetingFlags => check_weapon_targeting_flags => cache_handle_targeted_click,
        // this = unit, a1 tech_id, a2 target_unit, a3 fow_unit_id, a4 x, a5 y,
        // a6 u16 *opt_error_string_id
        CheckTechTargeting => check_tech_targeting => cache_handle_targeted_click,
        // this = unit, a1 order, a2 target, a3 x, a4 y, a5 u16 *opt_error_string_id
        CheckOrderTargeting => check_order_targeting => cache_handle_targeted_click,
        // this = unit, a1 order, a2 fow_unit_id, a3 x, a4 y, a5 u16 *opt_error_string_id
        CheckFowOrderTargeting => check_fow_order_targeting => cache_handle_targeted_click,
        AiFocusDisabled => ai_focus_disabled => cache_step_order,
        AiFocusAir => ai_focus_air => cache_step_order,
        FileExists => file_exists => cache_open_file,
        // Hook after unit strength / sprite vision sync init is done, but
        // before map is loaded.
        InitGameBeforeMapLoadHook => init_game_before_map_load_hook => cache_unit_strength_etc,
        CreateStartingUnits => create_starting_units => cache_unit_strength_etc,
        CreateTeamGameStartingUnits => create_team_game_starting_units => cache_unit_strength_etc,
        StepTrain => step_train => cache_order_train,
        AddAiToTrainedUnit => add_ai_to_trained_unit => cache_order_train,
        CancelQueuedUnit => cancel_queued_unit => cache_order_train,
        RefreshUi => refresh_ui => cache_order_train,
        GetSightRange => get_sight_range => cache_order_matrix,
        GetTargetAcquisitionRange => get_target_acquisition_range => cache_order_player_guard,
        PickAutoTarget => pick_auto_target => cache_order_player_guard,
        AttackUnit => attack_unit => cache_order_player_guard,
        GetAttackRange => get_attack_range => cache_order_arbiter_cloak,
        FindUnitBordersRect => find_unit_borders_rect => cache_order_arbiter_cloak,
        PickRandomTarget => pick_random_target => cache_order_tower,
        ConfigVsyncValue => config_vsync_value => cache_render_screen,
        GetRenderTarget => get_render_target => cache_render_screen,
        ClearRenderTarget => clear_render_target => cache_render_screen,
        MoveScreen => move_screen => cache_center_view_action,
        UpdateGameScreenSize => update_game_screen_size => cache_draw_game_layer,
        DrawTerrain => draw_terrain => cache_draw_game_layer,
        StepMovingBulletFrame => step_moving_bullet_frame => cache_step_bullet_frame,
        FlingyUpdateTargetDir => flingy_update_target_dir => cache_step_moving_bullet_frame,
        StepFlingySpeed => step_flingy_speed => cache_step_moving_bullet_frame,
        StepFlingyMovementStartEnd => step_flingy_movement_start_end => cache_step_moving_bullet_frame,
        StepFlingyPosition => step_flingy_position => cache_step_moving_bullet_frame,
        MoveSprite => move_sprite => cache_step_moving_bullet_frame,
        StepFlingyTurning => step_flingy_turning => cache_step_moving_bullet_frame,
        DoMissileDamage => do_missile_damage,
        HitUnit => hit_unit => cache_do_missile_damage,
        UnitWasHit => unit_was_hit => cache_do_missile_damage,
        DisableUnit => disable_unit => cache_do_missile_damage,
        AiUnitWasHit => ai_unit_was_hit => cache_do_missile_damage,
        LookupSoundId => lookup_sound_id => cache_do_missile_damage,
        PlaySoundAtUnit => play_sound_at_unit => cache_do_missile_damage,
        KillUnit => kill_unit => cache_do_missile_damage,
        UnitMaxEnergy => unit_max_energy => cache_do_missile_damage,
        SplashLurker => splash_lurker => cache_do_missile_damage,
        SplashFull => splash_full => cache_do_missile_damage,
        ForEachUnitInArea => for_each_unit_in_area => cache_do_missile_damage,
        HallucinationHit => hallucination_hit => cache_hit_unit,
        DoWeaponDamage => do_weapon_damage => cache_hit_unit,
        DamageUnit => damage_unit => cache_do_weapon_damage,
        ShowShieldOverlayForDirection => show_shield_overlay_for_direction => cache_do_weapon_damage,
        ShowShieldOverlay => show_shield_overlay => cache_do_weapon_damage,
        UnitUpdateStrength => unit_update_strength => cache_do_weapon_damage,
        UnitCalculateStrength => unit_calculate_strength => cache_do_weapon_damage,
        ReplayEnd => replay_end => cache_step_replay_commands,
        SFileOpenFileEx => sfile_open_file_ex => cache_read_mpq_file,
        SFileReadFileEx => sfile_read_file_ex => cache_read_mpq_file,
        SFileCloseFile => sfile_close_file => cache_read_mpq_file,
        InitIngameUi => init_ingame_ui => cache_init_ingame_ui,
        InitObsUi => init_obs_ui => cache_init_ingame_ui,
        LoadConsoles => load_consoles => cache_init_ingame_ui,
        InitConsoles => init_consoles => cache_init_ingame_ui,
        // Returns ui_consoles, but may end up initializing the global
        // if it hasn't been called yet.
        GetUiConsoles => get_ui_consoles => cache_init_ingame_ui,
        StopTargeting => stop_targeting => cache_game_screen_lclick,
        PlaceBuilding => place_building => cache_game_screen_lclick,
        SelectMouseUp => select_mouse_up => cache_game_screen_lclick,
        SelectMouseMove => select_mouse_move => cache_game_screen_lclick,
        ClipCursor => clip_cursor => cache_game_screen_lclick,
        DecideCursorType => decide_cursor_type => cache_select_mouse_up,
        SetCurrentCursorType => set_current_cursor_type => cache_select_mouse_up,
        // select_units(amount, ptr_arr, bool, bool)
        SelectUnits => select_units => cache_select_mouse_up,
        UnitCanBeInfested => unit_can_be_infested => cache_order_infest,
        UnitDetachAddon => unit_detach_addon => cache_order_infest,
        UnitCanRally => unit_can_rally => cache_order_infest,
        UnitSetHp => unit_set_hp => cache_order_zerg_build_self,
        TransformUnit => transform_unit => cache_order_zerg_build_self,
        StopCreepDisappearingAtBuilding => stop_creep_disappearing_at_building =>
                cache_order_zerg_build_self,
        PlaceCreepRect => place_creep_rect => cache_order_zerg_build_self,
        ShowUnit => show_unit => cache_order_nuke_launch,
        HideUnit => hide_unit => cache_order_nuke_launch,
        MoveUnit => move_unit => cache_order_nuke_launch,
        StopMoving => stop_moving => cache_order_nuke_launch,
        RemoveReferences => remove_references => cache_hide_unit,
        EndCollisionTracking => end_collision_tracking => cache_hide_unit,
        DropPowerup => drop_powerup => cache_kill_unit,
        AiRemoveUnit => ai_remove_unit => cache_kill_unit,
        FileReadFatalError => file_read_fatal_error,
        AiRemoveUnitMilitary => ai_remove_unit_military => cache_ai_remove_unit,
        AiRemoveUnitTown => ai_remove_unit_town => cache_ai_remove_unit,
        AddBuildingAi => add_building_ai => cache_add_ai_to_trained_unit,
        AddMilitaryAi => add_military_ai => cache_add_ai_to_trained_unit,
        AddTownUnitAi => add_town_unit_ai => cache_add_building_ai,
        InitImages => init_images => cache_init_images,
        InitTerrain => init_terrain => cache_init_terrain,
        // this = stack object, int, tile_id, vec4 *out
        // Returns u32 pointer to page texture id, and writes out for the texture coordinates
        // on success.
        // May also return null on invalid tile (Segfault due to caller not checking),
        // or pointer to -1 to make caller skip the tile.
        GetAtlasPageCoordsForTerrainTile => get_atlas_page_coords_for_terrain_tile =>
            cache_draw_terrain,
        // a1 = unit
        ShowFinishedUnitNotification => show_finished_unit_notification => cache_unit_morph,
        // this = unit, a1 bool use_construction_image (If false switches back to default image)
        SwitchConstructionImage => switch_construction_image => cache_unit_morph,
        // a1 = player, a2 unit_id, a3 show_error
        CheckResourcesForBuilding => check_resources_for_building => cache_unit_morph,
        // this = player_unit_skins, a1 player, a2 unit_id, a3 image_id
        // Return null when using default anim
        GetUnitSkin => get_unit_skin => cache_draw_image,
        AiRegionUpdateStrength => ai_region_update_strength => cache_ai_step_region,
        // a1 region; If there are enemies at region, set them as target for the region units
        AiRegionUpdateTarget => ai_region_update_target => cache_ai_step_region,
        AiRegionAbandonIfOverwhelmed => ai_region_abandon_if_overwhelmed => cache_ai_step_region,
        // a1 region; Pick target for attack force; can be far away
        AiRegionPickAttackTarget => ai_region_pick_attack_target => cache_ai_step_region,
        // a1 ctrl, a2 id, a3 time, a4 func * (64bit) / a4_8 func_by_value (32bit)
        CtrlSetTimer => ctrl_set_timer => cache_run_dialog_children,
        // a1 unit_id, a2 -1?, a3 -1?, a4 time
        TriggerTalkingPortrait => trigger_talking_portrait => cache_trigger_talking_portrait,
        // a1 unit_opt, a2 unit_id, a3 mode (1 = idle, 2 = talking)
        ShowPortrait => show_portrait => cache_trigger_talking_portrait,
        // a1?, a2 join_params, a3
        JoinCustomGame => join_custom_game => cache_join_custom_game,
        // a1 opt_filename, a2 size, a3 crc, a4 char **dirs, a5 dir_count, a6 String *out
        FindFileWithCrc => find_file_with_crc => cache_join_custom_game,
        StepLobbyNetwork => step_lobby_network => cache_step_lobby_network,
        SendQueuedLobbyCommands => send_queued_lobby_commands => cache_step_lobby_network,
        ProcessAsyncLobbyCommand => process_async_lobby_command => cache_step_lobby_state,
        // a1 data, a2 len, a3 player
        CommandLobbyMapP2p => command_lobby_map_p2p => cache_step_lobby_state,
        // a1 dir, a2 wildcard_str, a3 callback, a4, a5 recurse, a6 callback_ctx, a7 ctx2
        // callback: a1 dir_name, a2 file_entry, a3 ctx, a4 ctx2
        ForFilesInDir => for_files_in_dir => cache_find_file_with_crc,
        SimpleFileMatchCallback => simple_file_match_callback => cache_find_file_with_crc,
    }
}

results! {
    fn operand_analysis -> Option<Operand<'e>>;
    analyze_many_fn = analyze_many_op;
    enum OperandAnalysis {
        Game => game,
        Pathing => pathing,
        CommandUser => command_user,
        IsReplay => is_replay,
        LocalPlayerId => local_player_id,
        LocalPlayerName => local_player_name,
        LobbyState => lobby_state,
        DrawCursorMarker => draw_cursor_marker,
        Units => units,
        FirstAiScript => first_ai_script => cache_ai_step_frame,
        FirstGuardAi => first_guard_ai,
        PlayerAiTowns => player_ai_towns,
        PlayerAi => player_ai,
        Players => players => cache_ai_step_frame,
        // Globals that keep track of which (player, region_id) was being processed
        // as not all of them are handled in one frame
        StepAiRegionsRegion => step_ai_regions_region => cache_ai_step_frame,
        StepAiRegionsPlayer => step_ai_regions_player => cache_ai_step_frame,
        ResourceAreas => resource_areas => cache_ai_step_frame,
        // Variables for ai target ignore flag clearing,
        // first counter counts for 300 frames, after which it resets if
        // request bool is set or the second counter has counted to zero (from 6 * 300 frames)
        AiTargetIgnoreResetCounter => ai_target_ignore_reset_counter => cache_ai_step_frame,
        AiTargetIgnoreResetCounter2 => ai_target_ignore_reset_counter2 => cache_ai_step_frame,
        AiTargetIgnoreRequestReset => ai_target_ignore_request_reset => cache_ai_step_frame,
        AiMilitaryUpdateCounter => ai_military_update_counter => cache_ai_step_frame,
        Campaigns => campaigns,
        Fonts => fonts,
        StatusScreenMode => status_screen_mode,
        CheatFlags => cheat_flags,
        UnitStrength => unit_strength => cache_unit_strength_etc,
        SpriteIncludeInVisionSync => sprite_include_in_vision_sync => cache_unit_strength_etc,
        // This is just offset 0x7d on GameData, would not have to be a variable.
        // Not removed for now since CreateTeamGameStartingUnits and CreateStartingUnits analysis
        // still ends up needing to know where team game jump is, and keeping those working
        // would be additional work.
        TeamGameTeams => team_game_teams => cache_unit_strength_etc,
        WireframDdsgrp => wirefram_ddsgrp,
        ChkInitPlayers => chk_init_players,
        OriginalChkPlayerTypes => original_chk_player_types,
        AiTransportReachabilityCachedRegion => ai_transport_reachability_cached_region,
        // u16 array [0xe4 * 0xc]
        PlayerUnitSkins => player_unit_skins => cache_draw_image,
        ReplayData => replay_data,
        VertexBuffer => vertex_buffer,
        RngSeed => rng_seed => cache_rng,
        RngEnable => rng_enable => cache_rng,
        AiRegions => ai_regions => cache_regions,
        LoadedSave => loaded_save => cache_init_game,
        SpriteHlines => sprite_hlines => cache_sprites,
        SpriteHlinesEnd => sprite_hlines_end => cache_sprites,
        FirstFreeSprite => first_free_sprite => cache_sprites,
        LastFreeSprite => last_free_sprite => cache_sprites,
        FirstLoneSprite => first_lone_sprite => cache_sprites,
        LastLoneSprite => last_lone_sprite => cache_sprites,
        FirstFreeLoneSprite => first_free_lone_sprite => cache_sprites,
        LastFreeLoneSprite => last_free_lone_sprite => cache_sprites,
        ScreenX => screen_x => cache_coord_conversion,
        ScreenY => screen_y => cache_coord_conversion,
        Zoom => zoom => cache_coord_conversion,
        FirstFowSprite => first_fow_sprite => cache_fow_sprites,
        LastFowSprite => last_fow_sprite => cache_fow_sprites,
        FirstFreeFowSprite => first_free_fow_sprite => cache_fow_sprites,
        LastFreeFowSprite => last_free_fow_sprite => cache_fow_sprites,
        Sprites => sprites => cache_init_sprites,
        FirstActiveUnit => first_active_unit => cache_active_hidden_units,
        FirstHiddenUnit => first_hidden_unit => cache_active_hidden_units,
        MapTileFlags => map_tile_flags => cache_map_tile_flags,
        TooltipDrawFunc => tooltip_draw_func => cache_tooltip_related,
        CurrentTooltipCtrl => current_tooltip_ctrl => cache_tooltip_related,
        GraphicLayers => graphic_layers => cache_tooltip_related,
        IsMultiplayer => is_multiplayer => cache_select_map_entry,
        FirstActiveBullet => first_active_bullet => cache_bullet_creation,
        LastActiveBullet => last_active_bullet => cache_bullet_creation,
        FirstFreeBullet => first_free_bullet => cache_bullet_creation,
        LastFreeBullet => last_free_bullet => cache_bullet_creation,
        ActiveIscriptUnit => active_iscript_unit => cache_bullet_creation,
        UniqueCommandUser => unique_command_user => cache_selections,
        Selections => selections => cache_selections,
        GlobalEventHandlers => global_event_handlers => cache_ui_event_handlers,
        ReplayVisions => replay_visions => cache_replay_visions,
        ReplayShowEntireMap => replay_show_entire_map => cache_replay_visions,
        FirstPlayerUnit => first_player_unit => cache_replay_visions,
        NetPlayers => net_players,
        ScMainState => scmain_state => cache_game_init,
        LocalStormPlayerId => local_storm_player_id => cache_single_player_start,
        LocalUniquePlayerId => local_unique_player_id => cache_single_player_start,
        NetPlayerToGame => net_player_to_game => cache_single_player_start,
        NetPlayerToUnique => net_player_to_unique => cache_single_player_start,
        GameData => game_data => cache_single_player_start,
        // Local skins? Has some linked list etc and then u16 array of 0xab first units
        Skins => skins => cache_single_player_start,
        // u16 array [0xab * 0x10] Only first 0xab units are included, so player_unit_skins
        // is usually used instead.
        PlayerSkins => player_skins => cache_single_player_start,
        IsPaused => is_paused => cache_misc_clientside,
        IsPlacingBuilding => is_placing_building => cache_misc_clientside,
        IsTargeting => is_targeting => cache_misc_clientside,
        ClientSelection => client_selection => cache_game_screen_rclick,
        DialogReturnCode => dialog_return_code => cache_glucmpgn_events,
        BaseAnimSet => base_anim_set => cache_image_loading,
        ImageGrps => image_grps => cache_image_loading,
        ImageOverlays => image_overlays => cache_image_loading,
        ShieldOverlays => shield_overlays => cache_image_loading,
        FireOverlayMax => fire_overlay_max => cache_image_loading,
        AssetScale => asset_scale => cache_images_loaded,
        ImagesLoaded => images_loaded => cache_images_loaded,
        VisionUpdateCounter => vision_update_counter => cache_step_objects,
        VisionUpdated => vision_updated => cache_step_objects,
        FirstDyingUnit => first_dying_unit => cache_step_objects,
        FirstRevealer => first_revealer => cache_step_objects,
        FirstInvisibleUnit => first_invisible_unit => cache_step_objects,
        ActiveIscriptFlingy => active_iscript_flingy => cache_step_objects,
        ActiveIscriptBullet => active_iscript_bullet => cache_step_objects,
        // Disappearing creep state
        DcreepNextUpdate => dcreep_next_update => cache_step_objects,
        DcreepListSize => dcreep_list_size => cache_step_objects,
        DcreepListBegin => dcreep_list_begin => cache_step_objects,
        DcreepLookup => dcreep_lookup => cache_step_objects,
        CreepFuncs => creep_funcs => cache_step_objects,
        DcreepUnitNextUpdate => dcreep_unit_next_update => cache_step_objects,
        UnitCount => unit_count => cache_step_objects,
        LastDyingUnit => last_dying_unit => cache_step_objects,
        FirstFreeUnit => first_free_unit => cache_step_objects,
        LastFreeUnit => last_free_unit => cache_step_objects,
        // How many game steps until order wait timers are reset to be evenly
        // distributed across units.
        OrderTimerResetCounter => order_timer_reset_counter => cache_step_objects,
        SecondaryOrderTimerResetCounter => secondary_order_timer_reset_counter =>
            cache_step_objects,
        UnitShouldRevealArea => unit_should_reveal_area => cache_step_active_unit,
        MenuScreenId => menu_screen_id => cache_game_loop,
        NetPlayerFlags => net_player_flags => cache_step_network,
        PlayerTurns => player_turns => cache_step_network,
        PlayerTurnsSize => player_turns_size => cache_step_network,
        NetworkReady => network_ready => cache_step_network,
        NetUserLatency => net_user_latency,
        LastBulletSpawner => last_bullet_spawner => cache_do_attack,
        CmdIconsDdsGrp => cmdicons_ddsgrp => cache_cmdicons,
        CmdBtnsDdsGrp => cmdbtns_ddsgrp => cache_cmdicons,
        DatRequirementError => dat_requirement_error => cache_unit_requirements,
        CursorMarker => cursor_marker => cache_draw_game_layer,
        MainPalette => main_palette => cache_game_loop,
        PaletteSet => palette_set => cache_game_loop,
        TfontGam => tfontgam => cache_game_loop,
        SyncActive => sync_active => cache_game_loop,
        SyncData => sync_data => cache_game_loop,
        IscriptBin => iscript_bin => cache_step_iscript,
        FirstFreeImage => first_free_image => cache_step_iscript,
        LastFreeImage => last_free_image => cache_step_iscript,
        StormCommandUser => storm_command_user => cache_step_network,
        FirstFreeOrder => first_free_order => cache_prepare_issue_order,
        LastFreeOrder => last_free_order => cache_prepare_issue_order,
        AllocatedOrderCount => allocated_order_count => cache_prepare_issue_order,
        ReplayBfix => replay_bfix => cache_prepare_issue_order,
        ReplayGcfg => replay_gcfg => cache_prepare_issue_order,
        ContinueGameLoop => continue_game_loop => cache_game_loop,
        AntiTroll => anti_troll => cache_game_loop,
        StepGameFrames => step_game_frames => cache_game_loop,
        NextGameStepTick => next_game_step_tick => cache_game_loop,
        ReplaySeekFrame => replay_seek_frame => cache_game_loop,
        BnetController => bnet_controller => cache_process_events,
        MouseX => mouse_x => cache_mouse_xy,
        MouseY => mouse_y => cache_mouse_xy,
        FirstPylon => first_pylon => cache_pylon_aura,
        PylonAurasVisible => pylon_auras_visible => cache_pylon_aura,
        PylonRefresh => pylon_refresh => cache_pylon_aura,
        LocalGameResult => local_game_result => cache_sp_map_end,
        IsCustomSinglePlayer => is_custom_single_player => cache_sp_map_end_analysis,
        CurrentCampaignMission => current_campaign_mission => cache_sp_map_end_analysis,
        LocalVisions => local_visions => cache_update_unit_visibility,
        FirstFreeSelectionCircle => first_free_selection_circle => cache_update_unit_visibility,
        LastFreeSelectionCircle => last_free_selection_circle => cache_update_unit_visibility,
        UnitSkinMap => unit_skin_map => cache_update_unit_visibility,
        SpriteSkinMap => sprite_skin_map => cache_update_unit_visibility,
        GrpWireGrp => grpwire_grp => cache_multi_wireframes,
        GrpWireDdsGrp => grpwire_ddsgrp => cache_multi_wireframes,
        TranWireGrp => tranwire_grp => cache_multi_wireframes,
        TranWireDdsGrp => tranwire_ddsgrp => cache_multi_wireframes,
        StatusScreen => status_screen => cache_multi_wireframes,
        ReplayScenarioChk => replay_scenario_chk => cache_init_map_from_path,
        ReplayScenarioChkSize => replay_scenario_chk_size => cache_init_map_from_path,
        MapMpq => map_mpq => cache_init_map_from_path,
        MapHistory => map_history => cache_init_map_from_path,
        GameScreenLClickCallback => game_screen_lclick_callback => cache_ui_event_handlers,
        GameScreenRClickCallback => game_screen_rclick_callback => cache_ui_event_handlers,
        TargetedOrderUnit => targeted_order_unit => cache_start_targeting,
        TargetedOrderGround => targeted_order_ground => cache_start_targeting,
        TargetedOrderFow => targeted_order_fow => cache_start_targeting,
        MinimapCursorType => minimap_cursor_type => cache_start_targeting,
        Renderer => renderer => cache_render_screen,
        DrawCommands => draw_commands => cache_render_screen,
        TriggerCurrentPlayer => trigger_current_player => cache_center_view_action,
        // Game screen size in "BW pixels"
        //      - 1:1 with actual pixels in SD 640x480, and the coordinates used by gameplay logic.
        // Affected by zoom: zooming out => more pixels shown on screen => w/h grow
        // So in normal zoom, 4:3, width is 640, but height is 383 due to console covering
        // rest of the screen. In replay/obs height becomes 480 instead.
        // (Extra detail: 1.16.1 hardcodes the sizes as 640x400 instead of 640x383)
        GameScreenWidthBwpx => game_screen_width_bwpx => cache_center_view_action,
        GameScreenHeightBwPx => game_screen_height_bwpx => cache_center_view_action,
        ZoomActionActive => zoom_action_active => cache_draw_game_layer,
        ZoomActionMode => zoom_action_mode => cache_draw_game_layer,
        ZoomActionStart => zoom_action_start => cache_draw_game_layer,
        ZoomActionTarget => zoom_action_target => cache_draw_game_layer,
        ZoomActionCompletion => zoom_action_completion => cache_draw_game_layer,
        FlingyFlagsTmp => flingy_flags_tmp => cache_step_moving_bullet_frame,
        FlingyXOld => flingy_x_old => cache_step_moving_bullet_frame,
        FlingyYOld => flingy_y_old => cache_step_moving_bullet_frame,
        FlingyXNew => flingy_x_new => cache_step_moving_bullet_frame,
        FlingyYNew => flingy_y_new => cache_step_moving_bullet_frame,
        FlingyExactXNew => flingy_exact_x_new => cache_step_moving_bullet_frame,
        FlingyExactYNew => flingy_exact_y_new => cache_step_moving_bullet_frame,
        FlingyFlagsNew => flingy_flags_new => cache_step_moving_bullet_frame,
        FlingyShowEndWalkAnim => flingy_show_end_walk_anim => cache_step_moving_bullet_frame,
        FlingyShowStartWalkAnim => flingy_show_start_walk_anim => cache_step_moving_bullet_frame,
        // "What speed value was used for moving the flingy"
        FlingySpeedUsedForMove => flingy_speed_used_for_move => cache_step_moving_bullet_frame,
        MapWidthPixels => map_width_pixels => cache_step_moving_bullet_frame,
        MapHeightPixels => map_height_pixels => cache_step_moving_bullet_frame,
        ReplayHeader => replay_header => cache_step_replay_commands,
        // What locale is used when reading from mpq files
        MpqLocale => mpq_locale => cache_read_mpq_file,
        // HashTable u32 -> Console *
        UiConsoles => ui_consoles => cache_init_ingame_ui,
        ObserverUi => observer_ui => cache_init_ingame_ui,
        StatResIconsDdsGrp => statres_icons_ddsgrp => cache_init_statres,
        UseRgbColors => use_rgb_colors => cache_player_colors,
        // Array of [f32; 4], used if use_rgb_colors != 0
        RgbColors => rgb_colors => cache_player_colors,
        DisableColorChoice => disable_color_choice => cache_player_colors,
        // Relevant only before game start, specifies which slots in rgb_colors
        // should not be overwritten with color constants.
        UseMapSetRgbColor => use_map_set_rgb_color => cache_player_colors,
        // Some SC:R virtual lobby object
        GameLobby => game_lobby => cache_player_colors,
        // "In a game", but not necessarily in a started game.
        InLobbyOrGame => in_lobby_or_game => cache_player_colors,
        GameScreenRectWinPx => game_screen_rect_winpx => cache_game_screen_lclick,
        OnClipCursorEnd => on_clip_cursor_end => cache_game_screen_lclick,
        SelectStartX => select_start_x => cache_game_screen_lclick,
        SelectStartY => select_start_y => cache_game_screen_lclick,
        IsSelecting => is_selecting => cache_game_screen_lclick,
        FirstDialog => first_dialog => cache_run_dialog_children,
        RunDialogStack => run_dialog_stack => cache_run_dialog_children,
        // enum determining how update_game_screen_size behaves.
        UpdateGameScreenSizeMode => update_game_screen_size_mode => cache_update_game_screen_size,
        // float; 1.0 = game screen takes entire screen, usually ~0.8 to not have console
        // cover bottom of the map.
        GameScreenHeightRatio => game_screen_height_ratio => cache_update_game_screen_size,
        SfxData => sfx_data => cache_play_sound,
        SoundChannels => sound_channels => cache_play_sound,
        LastRevealer => last_revealer => cache_finish_unit_post,
        LastHiddenUnit => last_hidden_unit => cache_finish_unit_post,
        // Array of (Unit *attacker, Unit *target)[0x10 (pos)][0x20 (frame)] lurker spine hits
        // in last 32 frames
        LurkerHits => lurker_hits => cache_splash_lurker,
        LurkerHitsFrame => lurker_hits_frame => cache_splash_lurker,
        LurkerHitsPos => lurker_hits_pos => cache_splash_lurker,
        LastActiveUnit => last_active_unit => cache_hide_unit,
        PathArray => path_array => cache_hide_unit,
        FirstFreePath => first_free_path => cache_hide_unit,
        Images => images => cache_init_images,
        HpBarImages => hp_bar_images => cache_init_images,
        HpBarState => hp_bar_state => cache_init_images,
        SelectionCircles => selection_circles => cache_init_images,
        PlacementImages => placement_images => cache_init_images,
        PlacementRects => placement_rects => cache_init_images,
        FirstFreeHpBar => first_free_hp_bar => cache_init_images,
        LastFreeHpBar => last_free_hp_bar => cache_init_images,
        FirstFreePlacementImage => first_free_placement_image => cache_init_images,
        LastFreePlacementImage => last_free_placement_image => cache_init_images,
        FirstFreePlacementRect => first_free_placement_rect => cache_init_images,
        LastFreePlacementRect => last_free_placement_rect => cache_init_images,
        TilesetIndexedMapTiles => tileset_indexed_map_tiles => cache_init_terrain,
        Vx4MapTiles => vx4_map_tiles => cache_init_terrain,
        TerrainFramebuf => terrain_framebuf => cache_init_terrain,
        // Air units per 0x30 x 0x30 pixel tiles (For unstacking)
        RepulseState => repulse_state => cache_init_terrain,
        // SC:R array indexed by tileset id that contains various per-tileset data buffers
        // (Not sure if more than one is still loaded at once) in one point.
        TilesetData => tileset_data => cache_init_terrain,
        TileDefaultFlags => tile_default_flags => cache_init_terrain,
        TilesetCv5 => tileset_cv5 => cache_init_terrain,
        TilesetVx4Ex => tileset_vx4ex => cache_init_terrain,
        // tileset.vr4
        MinitileGraphics => minitile_graphics => cache_init_terrain,
        // tileset.vf4
        MinitileData => minitile_data => cache_init_terrain,
        FoliageState => foliage_state => cache_init_terrain,
        // Struct ptr containing (shared_ptr[2] sd_hd_videos, bool active?) for portrait video
        StatportVideos => statport_videos => cache_show_portrait,
        StatportTalkingPortraitActive => statport_talking_portrait_active => cache_show_portrait,
        // Which of 3 possible talking portraits is being shown
        StatportVideoId => statport_video_id => cache_show_portrait,
    }
}

pub struct AnalysisCache<'e, E: ExecutionState<'e>> {
    binary: &'e BinaryFile<E::VirtualAddress>,
    text: &'e BinarySection<E::VirtualAddress>,
    relocs: Cached<Rc<Vec<E::VirtualAddress>>>,
    globals_with_values: Cached<Rc<Vec<RelocValues<E::VirtualAddress>>>>,
    functions: Cached<Rc<Vec<E::VirtualAddress>>>,
    functions_with_callers: Cached<Rc<Vec<FuncCallPair<E::VirtualAddress>>>>,
    vtables: Cached<Rc<Vtables<'e, E::VirtualAddress>>>,
    firegraft_addresses: Cached<Rc<FiregraftAddresses<E::VirtualAddress>>>,
    aiscript_hook: Option<AiScriptHook<'e, E::VirtualAddress>>,
    // 0 = Not calculated, 1 = Not found
    address_results: [E::VirtualAddress; AddressAnalysis::COUNT],
    // None = Not calculated, Custom(1234578) = Not found
    operand_results: [Option<Operand<'e>>; OperandAnalysis::COUNT],
    // Technically there are 0xbd order, but the last one is fully no-op so it cannot
    // have a step function.
    step_order_funcs: [E::VirtualAddress; 0xbc],
    operand_not_found: Operand<'e>,
    process_commands_switch: Cached<Option<CompleteSwitch<'e>>>,
    process_lobby_commands_switch: Cached<Option<CompleteSwitch<'e>>>,
    bnet_message_switch: Option<CompleteSwitch<'e>>,
    command_lengths: Cached<Rc<Vec<u32>>>,
    step_order_hidden: Cached<Rc<Vec<StepOrderHiddenHook<'e, E::VirtualAddress>>>>,
    step_secondary_order: Cached<Rc<Vec<SecondaryOrderHook<'e, E::VirtualAddress>>>>,
    step_iscript_hook: Option<StepIscriptHook<'e, E::VirtualAddress>>,
    sprite_x_position: Option<(Operand<'e>, u32, MemAccessSize)>,
    sprite_y_position: Option<(Operand<'e>, u32, MemAccessSize)>,
    eud: Cached<Rc<EudTable<'e>>>,
    renderer_vtables: Cached<Rc<Vec<E::VirtualAddress>>>,
    snp_definitions: Cached<Option<SnpDefinitions<'e>>>,
    sprite_struct_size: u16,
    net_player_size: u16,
    skins_size: u16,
    anim_struct_size: u16,
    bnet_message_vtable_type: u16,
    create_game_dialog_vtbl_on_multiplayer_create: u16,
    join_param_variant_type_offset: u16,
    limits: Cached<Rc<Limits<'e, E::VirtualAddress>>>,
    prism_shaders: Cached<PrismShaders<E::VirtualAddress>>,
    dat_patches: Cached<Option<Rc<DatPatches<'e, E::VirtualAddress>>>>,
    run_triggers: Cached<RunTriggers<E::VirtualAddress>>,
    trigger_unit_count_caches: Cached<TriggerUnitCountCaches<'e>>,
    replay_minimap_unexplored_fog_patch: Cached<Option<Rc<Patch<E::VirtualAddress>>>>,
    deserialize_lone_sprite_patch: Cached<Option<Rc<Patch<E::VirtualAddress>>>>,
    crt_fastfail: Cached<Rc<Vec<E::VirtualAddress>>>,
    unwind_functions: Cached<Rc<x86_64_unwind::UnwindFunctions>>,
    dat_tables: DatTables<'e>,
}

pub struct ArgCache<'e, E: ExecutionState<'e>> {
    args: [Operand<'e>; 8],
    ctx: scarf::OperandCtx<'e>,
    phantom: std::marker::PhantomData<E>,
}

impl<'e, E: ExecutionState<'e>> ArgCache<'e, E> {
    fn new(ctx: OperandCtx<'e>) -> ArgCache<'e, E> {
        let is_x64 = <E::VirtualAddress as VirtualAddress>::SIZE == 8;
        let stack_pointer = ctx.register(4);
        let args = array_init::array_init(|i| {
            if is_x64 {
                match i {
                    0 => ctx.register(1),
                    1 => ctx.register(2),
                    2 => ctx.register(8),
                    3 => ctx.register(9),
                    _ => ctx.mem64(
                        stack_pointer,
                        i as u64 * 8,
                    ),
                }
            } else {
                ctx.mem32(
                    stack_pointer,
                    i as u64 * 4,
                )
            }
        });
        ArgCache {
            args,
            ctx,
            phantom: std::marker::PhantomData,
        }
    }

    /// Returns operand corresponding to location of argument *before* call instruction
    /// is executed.
    pub fn on_call(&self, index: u8) -> Operand<'e> {
        if (index as usize) < self.args.len() {
            self.args[index as usize]
        } else {
            let size = <E::VirtualAddress as VirtualAddress>::SIZE as u64;
            let is_x64 = <E::VirtualAddress as VirtualAddress>::SIZE == 8;
            let stack_pointer = self.ctx.register(4);
            let mem_size = match is_x64 {
                true => MemAccessSize::Mem64,
                false => MemAccessSize::Mem32,
            };
            self.ctx.mem_any(
                mem_size,
                stack_pointer,
                index as u64 * size,
            )
        }
    }

    pub fn on_call_u8(&self, index: u8) -> Operand<'e> {
        let val = self.on_call(index);
        self.ctx.and_const(val, 0xff)
    }

    pub fn on_call_u32(&self, index: u8) -> Operand<'e> {
        let val = self.on_call(index);
        self.ctx.and_const(val, 0xffff_ffff)
    }

    pub fn on_call_f32(&self, index: u8) -> Operand<'e> {
        if E::VirtualAddress::SIZE == 8 {
            if index < 4 {
                self.ctx.xmm(index, 0)
            } else {
                self.ctx.and_const(self.on_call(index), 0xffff_ffff)
            }
        } else {
            self.on_call(index)
        }
    }

    /// Returns operand corresponding to location of nth non-this argument *before*
    /// call instruction when calling convention is thiscall.
    pub fn on_thiscall_call(&self, index: u8) -> Operand<'e> {
        let is_x64 = <E::VirtualAddress as VirtualAddress>::SIZE == 8;
        if !is_x64 {
            self.on_call(index)
        } else {
            self.on_call(index + 1)
        }
    }

    pub fn on_thiscall_call_u8(&self, index: u8) -> Operand<'e> {
        let val = self.on_thiscall_call(index);
        self.ctx.and_const(val, 0xff)
    }

    /// Returns operand corresponding to location of argument *on function entry*.
    pub fn on_entry(&self, index: u8) -> Operand<'e> {
        let is_x64 = <E::VirtualAddress as VirtualAddress>::SIZE == 8;
        let ctx = self.ctx;
        let stack_pointer = ctx.register(4);
        if !is_x64 {
            if index as usize + 1 < self.args.len() {
                self.args[index as usize + 1]
            } else {
                ctx.mem32(
                    stack_pointer,
                    (index as u64 + 1) * 4,
                )
            }
        } else {
            if index < 4 {
                self.args[index as usize]
            } else {
                ctx.mem64(
                    stack_pointer,
                    (index as u64 + 1) * 8,
                )
            }
        }
    }

    /// Returns operand corresponding to location of nth non-this argument *on function entry*
    /// when calling convention is thiscall.
    pub fn on_thiscall_entry(&self, index: u8) -> Operand<'e> {
        let is_x64 = <E::VirtualAddress as VirtualAddress>::SIZE == 8;
        if !is_x64 {
            self.on_entry(index)
        } else {
            self.on_entry(index + 1)
        }
    }
}

macro_rules! declare_dat {
    ($($struct_field:ident, $filename:expr, $enum_variant:ident,)*) => {
        struct DatTables<'e> {
            $($struct_field: Option<Option<DatTablePtr<'e>>>,)*
        }

        impl<'e> DatTables<'e> {
            fn new() -> DatTables<'e> {
                DatTables {
                    $($struct_field: None,)*
                }
            }

            fn field(&mut self, field: DatType) ->
                (&mut Option<Option<DatTablePtr<'e>>>, &'static str)
            {
                match field {
                    $(DatType::$enum_variant =>
                      (&mut self.$struct_field, concat!("arr\\", $filename)),)*
                }
            }
        }

        #[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
        pub enum DatType {
            $($enum_variant,)*
        }
    }
}

declare_dat! {
    units, "units.dat", Units,
    weapons, "weapons.dat", Weapons,
    flingy, "flingy.dat", Flingy,
    upgrades, "upgrades.dat", Upgrades,
    techdata, "techdata.dat", TechData,
    sprites, "sprites.dat", Sprites,
    images, "images.dat", Images,
    orders, "orders.dat", Orders,
    sfxdata, "sfxdata.dat", SfxData,
    portdata, "portdata.dat", PortData,
    mapdata, "mapdata.dat", MapData,
}

impl<'e, E: ExecutionState<'e>> Analysis<'e, E> {
    pub fn new(
        binary: &'e BinaryFile<E::VirtualAddress>,
        ctx: scarf::OperandCtx<'e>,
    ) -> Analysis<'e, E> {
        let text = binary.section(b".text\0\0\0").unwrap();
        let data = binary.section(b".data\0\0\0").unwrap();
        let rdata = binary.section(b".rdata\0\0").unwrap();
        let arg_cache = ArgCache::new(ctx);
        let bump = Bump::new();
        Analysis {
            cache: AnalysisCache {
                binary,
                text,
                relocs: Default::default(),
                globals_with_values: Default::default(),
                functions: Default::default(),
                functions_with_callers: Default::default(),
                vtables: Default::default(),
                firegraft_addresses: Default::default(),
                aiscript_hook: Default::default(),
                address_results:
                    [E::VirtualAddress::from_u64(0); AddressAnalysis::COUNT],
                operand_results: [None; OperandAnalysis::COUNT],
                step_order_funcs: [E::VirtualAddress::from_u64(0); 0xbc],
                operand_not_found: ctx.custom(0x12345678),
                process_commands_switch: Default::default(),
                process_lobby_commands_switch: Default::default(),
                bnet_message_switch: Default::default(),
                command_lengths: Default::default(),
                step_order_hidden: Default::default(),
                step_secondary_order: Default::default(),
                step_iscript_hook: Default::default(),
                sprite_x_position: Default::default(),
                sprite_y_position: Default::default(),
                eud: Default::default(),
                renderer_vtables: Default::default(),
                snp_definitions: Default::default(),
                sprite_struct_size: 0,
                net_player_size: 0,
                skins_size: 0,
                anim_struct_size: 0,
                bnet_message_vtable_type: 0,
                create_game_dialog_vtbl_on_multiplayer_create: 0,
                join_param_variant_type_offset: u16::MAX,
                limits: Default::default(),
                prism_shaders: Default::default(),
                dat_patches: Default::default(),
                run_triggers: Default::default(),
                trigger_unit_count_caches: Default::default(),
                replay_minimap_unexplored_fog_patch: Default::default(),
                deserialize_lone_sprite_patch: Default::default(),
                crt_fastfail: Default::default(),
                unwind_functions: Default::default(),
                dat_tables: DatTables::new(),
            },
            shareable: AnalysisCtx {
                binary,
                binary_sections: BinarySections {
                    rdata,
                    data,
                    text,
                },
                ctx,
                bump,
                arg_cache,
            },
        }
    }

    pub fn ctx(&self) -> OperandCtx<'e> {
        self.shareable.ctx
    }

    fn is_valid_function(address: E::VirtualAddress) -> bool {
        address.as_u64() & 0xf == 0
    }

    /// Entry point for any analysis calls.
    /// Creates AnalysisCtx from self that is used across actual analysis functions.
    fn enter<F: for<'b> FnOnce(&mut AnalysisCache<'e, E>, &AnalysisCtx<'e, E>) -> R, R>(
        &mut self,
        func: F,
    ) -> R {
        let ret = func(&mut self.cache, &self.shareable);
        self.shareable.bump.reset();
        ret
    }

    fn analyze_many_addr<F>(
        &mut self,
        addr: AddressAnalysis,
        cache_fn: F,
    ) -> Option<E::VirtualAddress>
    where F: FnOnce(&mut AnalysisCache<'e, E>, &AnalysisCtx<'e, E>)
    {
        if self.cache.address_results[addr as usize] == E::VirtualAddress::from_u64(0) {
            self.enter(cache_fn);
        }
        Some(self.cache.address_results[addr as usize])
            .filter(|&addr| addr != E::VirtualAddress::from_u64(1))
    }

    fn analyze_many_op<F>(&mut self, op: OperandAnalysis, cache_fn: F) -> Option<Operand<'e>>
    where F: FnOnce(&mut AnalysisCache<'e, E>, &AnalysisCtx<'e, E>)
    {
        if self.cache.operand_results[op as usize].is_none() {
            self.enter(cache_fn);
        }
        self.cache.operand_results[op as usize]
            .filter(|&op| op != self.cache.operand_not_found)
    }

    pub fn firegraft_addresses(&mut self) -> Rc<FiregraftAddresses<E::VirtualAddress>> {
        self.enter(|x, s| x.firegraft_addresses(s))
    }

    pub fn dat(&mut self, ty: DatType) -> Option<DatTablePtr<'e>> {
        self.enter(|x, s| x.dat(ty, s))
    }

    pub fn open_file(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::open_file)
    }

    pub fn step_objects(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::step_objects)
    }

    pub fn game(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::game)
    }

    pub fn aiscript_hook(&mut self) -> Option<AiScriptHook<'e, E::VirtualAddress>> {
        self.enter(AnalysisCache::aiscript_hook)
    }

    pub fn pathing(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::pathing)
    }

    pub fn command_user(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::command_user)
    }

    /// May return an overly long array
    pub fn command_lengths(&mut self) -> Rc<Vec<u32>> {
        self.enter(AnalysisCache::command_lengths)
    }

    pub fn is_replay(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::is_replay)
    }

    pub fn send_command(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::send_command)
    }

    pub fn renderer_vtables(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        self.enter(AnalysisCache::renderer_vtables)
    }

    pub fn vtables(&mut self) -> Vec<E::VirtualAddress> {
        self.enter(AnalysisCache::all_vtables)
    }

    pub fn vtables_for_class(&mut self, name: &[u8]) -> Vec<E::VirtualAddress> {
        self.enter(|x, s| x.vtables_for_class(name, s))
    }

    pub fn skins_size(&mut self) -> Option<u32> {
        self.player_skins()
            .map(|_| self.cache.skins_size as u32)
    }

    pub fn local_player_id(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::local_player_id)
    }

    pub fn load_images(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::load_images)
    }

    pub fn local_player_name(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::local_player_name)
    }

    pub fn net_user_latency(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::net_user_latency)
    }

    pub fn net_format_turn_rate(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::net_format_turn_rate)
    }

    pub fn init_game_network(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::init_game_network)
    }

    pub fn snp_definitions(&mut self) -> Option<SnpDefinitions<'e>> {
        self.enter(AnalysisCache::snp_definitions)
    }

    pub fn lobby_state(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::lobby_state)
    }

    pub fn step_order(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::step_order)
    }

    pub fn order_function(&mut self, order: u8) -> Option<E::VirtualAddress> {
        self.enter(|x, s| x.order_function(order, s))
    }

    pub fn step_order_hidden(&mut self) ->
        Rc<Vec<step_order::StepOrderHiddenHook<'e, E::VirtualAddress>>>
    {
        self.enter(AnalysisCache::step_order_hidden)
    }

    pub fn step_secondary_order(&mut self) ->
        Rc<Vec<step_order::SecondaryOrderHook<'e, E::VirtualAddress>>>
    {
        self.enter(AnalysisCache::step_secondary_order)
    }

    pub fn step_iscript(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::step_iscript)
    }

    pub fn step_iscript_hook(&mut self) -> Option<StepIscriptHook<'e, E::VirtualAddress>> {
        self.step_iscript_switch()?;
        self.cache.step_iscript_hook
    }

    pub fn add_overlay_iscript(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::add_overlay_iscript)
    }

    pub fn draw_cursor_marker(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::draw_cursor_marker)
    }

    pub fn play_smk(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::play_smk)
    }

    pub fn units(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::units)
    }

    pub fn first_guard_ai(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::first_guard_ai)
    }

    pub fn player_ai_towns(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::player_ai_towns)
    }

    pub fn player_ai(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::player_ai)
    }

    pub fn sprite_x_position(&mut self) -> Option<(Operand<'e>, u32, MemAccessSize)> {
        self.sprite_hlines(); // Ends up caching sprite pos
        self.cache.sprite_x_position
    }

    pub fn sprite_y_position(&mut self) -> Option<(Operand<'e>, u32, MemAccessSize)> {
        self.sprite_hlines(); // Ends up caching sprite pos
        self.cache.sprite_y_position
    }

    pub fn eud_table(&mut self) -> Rc<EudTable<'e>> {
        self.enter(AnalysisCache::eud_table)
    }

    pub fn net_players_size(&mut self) -> Option<(Operand<'e>, u32)> {
        self.analyze_many_op(
            OperandAnalysis::NetPlayers,
            AnalysisCache::cache_net_players,
        ).map(|x| (x, self.cache.net_player_size.into()))
    }

    pub fn net_players(&mut self) -> Option<Operand<'e>> {
        self.net_players_size().map(|x| x.0)
    }

    pub fn campaigns(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::campaigns)
    }

    pub fn ai_update_attack_target(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ai_update_attack_target)
    }

    pub fn is_outside_game_screen(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::is_outside_game_screen)
    }

    pub fn fonts(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::fonts)
    }

    pub fn sprite_array(&mut self) -> Option<(Operand<'e>, u32)> {
        self.sprites()
            .map(|x| (x, self.cache.sprite_struct_size.into()))
    }

    pub fn limits(&mut self) -> Rc<Limits<'e, E::VirtualAddress>> {
        self.enter(AnalysisCache::limits)
    }

    /// Memory allocation function that at least TTF code uses.
    ///
    /// (Should be Win32 HeapAlloc with a specific heap)
    pub fn ttf_malloc(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ttf_malloc)
    }

    /// Offset to CreateGameScreen.OnMultiplayerGameCreate in the dialog's vtable
    pub fn create_game_dialog_vtbl_on_multiplayer_create(&mut self) -> Option<usize> {
        self.create_game_multiplayer();
        Some(self.cache.create_game_dialog_vtbl_on_multiplayer_create as usize)
            .filter(|&x| x != 0)
    }

    pub fn draw_graphic_layers(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::draw_graphic_layers)
    }

    pub fn prism_vertex_shaders(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        self.enter(AnalysisCache::prism_vertex_shaders)
    }

    pub fn prism_pixel_shaders(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        self.enter(AnalysisCache::prism_pixel_shaders)
    }

    pub fn join_game(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::join_game)
    }

    pub fn snet_initialize_provider(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::snet_initialize_provider)
    }

    pub fn set_status_screen_tooltip(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::set_status_screen_tooltip)
    }

    pub fn unit_wireframe_type(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::unit_wireframe_type)
    }

    pub fn campaign_map_names(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::campaign_map_names)
    }

    pub fn dat_patches(&mut self) -> Option<Rc<DatPatches<'e, E::VirtualAddress>>> {
        self.enter(AnalysisCache::dat_patches)
    }

    pub fn smem_alloc(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::smem_alloc)
    }

    pub fn smem_free(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::smem_free)
    }

    pub fn allocator(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::allocator)
    }

    pub fn status_screen_mode(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::status_screen_mode)
    }

    pub fn check_dat_requirements(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::check_dat_requirements)
    }

    pub fn cheat_flags(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::cheat_flags)
    }

    /// Note: Struct that contains { grp, sd_ddsgrp, hd_ddsgrp }
    pub fn wirefram_ddsgrp(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::wirefram_ddsgrp)
    }

    pub fn init_status_screen(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::init_status_screen)
    }

    pub fn trigger_conditions(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::trigger_conditions)
    }

    pub fn trigger_actions(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::trigger_actions)
    }

    pub fn trigger_completed_units_cache(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::trigger_completed_units_cache)
    }

    pub fn trigger_all_units_cache(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::trigger_all_units_cache)
    }

    pub fn chk_init_players(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::chk_init_players)
    }

    pub fn original_chk_player_types(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::original_chk_player_types)
    }

    pub fn give_ai(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::give_ai)
    }

    pub fn play_sound(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::play_sound)
    }

    pub fn do_missile_damage(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::do_missile_damage)
    }

    pub fn ai_prepare_moving_to(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ai_prepare_moving_to)
    }

    pub fn ai_transport_reachability_cached_region(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::ai_transport_reachability_cached_region)
    }

    /// A patch to show resource fog sprites on minimap in replays even if they're
    /// in unexplored fog.
    pub fn replay_minimap_unexplored_fog_patch(
        &mut self,
    ) -> Option<Rc<Patch<E::VirtualAddress>>> {
        self.enter(AnalysisCache::replay_minimap_unexplored_fog_patch)
    }

    /// A patch to fix orr-by-one in loading save when lone/fow sprite array is full
    pub fn deserialize_lone_sprite_patch(&mut self) -> Option<Rc<Patch<E::VirtualAddress>>> {
        self.enter(AnalysisCache::deserialize_lone_sprite_patch)
    }

    pub fn draw_minimap_units(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::draw_minimap_units)
    }

    pub fn step_replay_commands(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::step_replay_commands)
    }

    pub fn replay_data(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::replay_data)
    }

    pub fn ai_train_military(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ai_train_military)
    }

    pub fn ai_add_military_to_region(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ai_add_military_to_region)
    }

    /// Renderer's vertex (and index) buffer
    pub fn vertex_buffer(&mut self) -> Option<Operand<'e>> {
        self.enter(AnalysisCache::vertex_buffer)
    }

    pub fn crt_fastfail(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        self.enter(AnalysisCache::crt_fastfail)
    }

    pub fn clamp_zoom(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::clamp_zoom)
    }

    pub fn ai_spell_cast(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::ai_spell_cast)
    }

    pub fn give_unit(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::give_unit)
    }

    pub fn set_unit_player(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::set_unit_player)
    }

    pub fn start_udp_server(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::start_udp_server)
    }

    pub fn anim_struct_size(&mut self) -> Option<u16> {
        self.base_anim_set().map(|_| self.cache.anim_struct_size)
    }

    pub fn draw_game_layer(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::draw_game_layer)
    }

    pub fn bnet_message_vtable_type(&mut self) -> Option<u16> {
        self.bnet_controller()?;
        self.cache.bnet_message_switch?;
        Some(self.cache.bnet_message_vtable_type)
    }

    pub fn bnet_message_switch_op(&mut self) -> Option<Operand<'e>> {
        Some(self.cache.bnet_message_switch?.as_operand(self.shareable.ctx))
    }

    pub fn join_param_variant_type_offset(&mut self) -> Option<usize> {
        self.enter(AnalysisCache::join_param_variant_type_offset)
    }

    pub fn file_read_fatal_error(&mut self) -> Option<E::VirtualAddress> {
        self.enter(AnalysisCache::file_read_fatal_error)
    }

    /// Mainly for tests/dump
    pub fn dat_patches_debug_data(
        &mut self,
    ) -> Option<DatPatchesDebug<'e, E::VirtualAddress>> {
        let patches = self.dat_patches()?;
        let warnings = patches.warnings.get_all().into();
        let mut map = fxhash::FxHashMap::default();
        let mut replaces = Vec::new();
        let mut func_replaces = Vec::new();
        let mut hooks = Vec::new();
        let mut two_step_hooks = Vec::new();
        let mut ext_array_patches = Vec::new();
        let mut ext_array_args = Vec::new();
        let mut grp_index_hooks = Vec::new();
        let mut grp_texture_hooks = Vec::new();
        for patch in &patches.patches {
            match *patch {
                DatPatch::Array(ref a) => {
                    let vec = &mut map.entry(a.dat)
                        .or_insert_with(DatTablePatchesDebug::default)
                        .array_patches;
                    while vec.len() <= a.field_id as usize {
                        vec.push(Vec::new());
                    }
                    vec[a.field_id as usize].push(
                        (a.address, a.entry, a.orig_entry, a.byte_offset)
                    );
                    vec[a.field_id as usize].sort_unstable();
                }
                DatPatch::EntryCount(ref a) => {
                    let entry_counts = &mut map.entry(a.dat)
                        .or_insert_with(DatTablePatchesDebug::default)
                        .entry_counts;
                    entry_counts.push(a.address);
                    entry_counts.sort_unstable();
                }
                DatPatch::Replace(addr, offset, len) => {
                    let data = &patches.code_bytes[offset as usize..][..len as usize];
                    replaces.push((addr, data.into()));
                }
                DatPatch::Hook(addr, offset, len, skip) => {
                    let data = &patches.code_bytes[offset as usize..][..len as usize];
                    hooks.push((addr, skip, data.into()));
                }
                DatPatch::TwoStepHook(addr, free_space, offset, len, skip) => {
                    let data = &patches.code_bytes[offset as usize..][..len as usize];
                    two_step_hooks.push((addr, free_space, skip, data.into()));
                }
                DatPatch::ReplaceFunc(addr, ty) => {
                    func_replaces.push((addr, ty));
                }
                DatPatch::ExtendedArray(ref a) => {
                    ext_array_patches.push(
                        (a.address, a.two_step, a.instruction_len, a.ext_array_id, a.index)
                    );
                }
                DatPatch::ExtendedArrayArg(addr, args) => {
                    let args = args.iter().enumerate()
                        .filter_map(|x| Some((x.0, x.1.checked_sub(1)?)))
                        .collect();
                    ext_array_args.push((addr, args));
                }
                DatPatch::GrpIndexHook(addr) => {
                    grp_index_hooks.push(addr);
                }
                DatPatch::GrpTextureHook(ref a) => {
                    grp_texture_hooks.push(
                        (a.address, a.instruction_len, a.dest, a.base, a.index_bytes, a.mem_size,
                            a.mem_offset)
                    );
                }
            }
        }
        replaces.sort_unstable_by_key(|x| x.0);
        func_replaces.sort_unstable_by_key(|x| x.0);
        hooks.sort_unstable_by_key(|x| x.0);
        two_step_hooks.sort_unstable_by_key(|x| x.0);
        ext_array_patches.sort_unstable_by_key(|x| (x.3, x.0));
        ext_array_args.sort_unstable_by_key(|x| x.0);
        grp_index_hooks.sort_unstable_by_key(|x| *x);
        grp_texture_hooks.sort_unstable_by_key(|x| x.0);
        let campaign_map_names = patches.campaign_map_names;
        Some(DatPatchesDebug {
            warnings,
            tables: map,
            replaces,
            func_replaces,
            hooks,
            two_step_hooks,
            ext_array_patches,
            ext_array_args,
            grp_index_hooks,
            grp_texture_hooks,
            campaign_map_names,
        })
    }
}

impl<'e, E: ExecutionState<'e>> AnalysisCache<'e, E> {
    pub fn functions(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        let binary = self.binary;
        let text = self.text;
        let relocs = self.relocs();
        self.functions.get_or_insert_with(|| {
            let mut functions = scarf::analysis::find_functions::<E>(binary, &relocs);
            functions.retain(|&fun| Analysis::<E>::is_valid_function(fun));

            // Add functions which immediately jump to another
            let text_end = text.virtual_address + text.virtual_size;
            let mut extra_funcs = Vec::with_capacity(64);
            for &func in &functions {
                let relative = func.as_u64().wrapping_sub(text.virtual_address.as_u64()) as usize;
                if let Some(bytes) = text.data.get(relative..).and_then(|x| x.get(..5)) {
                    if bytes[0] == 0xe9 {
                        let offset = LittleEndian::read_u32(&bytes[1..]);
                        let dest = func.as_u64()
                            .wrapping_add(5)
                            .wrapping_add(offset as i32 as i64 as u64);
                        let dest = E::VirtualAddress::from_u64(dest);
                        if dest >= text.virtual_address && dest <= text_end {
                            if let Err(index) = functions.binary_search(&dest) {
                                extra_funcs.push((dest, index));
                            }
                        }
                    }
                }
            }
            // Insert functions without having to memmove every entry more than once
            extra_funcs.sort_unstable_by_key(|x| x.0);
            extra_funcs.dedup_by_key(|x| x.0);
            let mut end_pos = functions.len();
            functions.resize_with(
                functions.len() + extra_funcs.len(),
                || E::VirtualAddress::from_u64(0),
            );
            for (i, &(val, index)) in extra_funcs.iter().enumerate().rev() {
                functions.copy_within(index..end_pos, index + i + 1);
                functions[index + i] = val;
                end_pos = index;
            }
            Rc::new(functions)
        }).clone()
    }

    pub fn globals_with_values(&mut self) -> Rc<Vec<RelocValues<E::VirtualAddress>>> {
        let result = match self.globals_with_values.is_none() {
            true => {
                let relocs = self.relocs();
                let mut result = match scarf::analysis::relocs_with_values(self.binary, &relocs) {
                    Ok(o) => o,
                    Err(e) => {
                        debug!("Error getting relocs with values: {}", e);
                        Vec::new()
                    }
                };
                if E::VirtualAddress::SIZE == 8 {
                    let mut text_globals = x86_64_globals::x86_64_globals(self.binary);
                    if result.len() < text_globals.len() {
                        std::mem::swap(&mut result, &mut text_globals);
                    }
                    result.extend_from_slice(&text_globals);
                    result.sort_unstable_by_key(|x| x.value);
                }
                // Would be nice to sort by address for reliable order,
                // but it ends up being quite expensive.
                // Will have to just have users accept complexity from
                // unreliable ordering of same value for now..
                result
            }
            false => Vec::new(),
        };
        self.globals_with_values.get_or_insert_with(|| {
            Rc::new(result)
        }).clone()
    }

    /// Sorted by address
    pub fn relocs(&mut self) -> Rc<Vec<E::VirtualAddress>> {
        let relocs = match self.relocs.is_none() {
            true => match scarf::analysis::find_relocs::<E>(self.binary) {
                Ok(s) => s,
                Err(e) => {
                    debug!("Error getting relocs: {}", e);
                    Vec::new()
                }
            },
            false => Vec::new(),
        };
        self.relocs.get_or_insert_with(|| {
            Rc::new(relocs)
        }).clone()
    }

    // TODO Should share search w/ self.functions
    fn functions_with_callers(&mut self) -> Rc<Vec<FuncCallPair<E::VirtualAddress>>> {
        let binary = self.binary;
        self.functions_with_callers.get_or_insert_with(|| {
            let mut functions = scarf::analysis::find_functions_with_callers::<E>(binary);
            functions.retain(|fun| Analysis::<E>::is_valid_function(fun.callee));
            Rc::new(functions)
        }).clone()
    }

    pub fn function_finder<'s>(&'s mut self) -> FunctionFinder<'s, 'e, E> {
        if self.functions.is_none() {
            self.functions();
        }
        if self.globals_with_values.is_none() {
            self.globals_with_values();
        }
        if self.functions_with_callers.is_none() {
            self.functions_with_callers();
        }
        let functions = self.functions.0.as_deref().unwrap();
        let globals_with_values = self.globals_with_values.0.as_deref().unwrap();
        let functions_with_callers = self.functions_with_callers.0.as_deref().unwrap();
        FunctionFinder::new(functions, globals_with_values, functions_with_callers)
    }

    pub fn unwind_functions(&mut self) -> Rc<x86_64_unwind::UnwindFunctions> {
        let binary = self.binary;
        self.unwind_functions.get_or_insert_with(|| {
            Rc::new(x86_64_unwind::UnwindFunctions::new(binary))
        }).clone()
    }

    fn cache_single_address<F>(
        &mut self,
        addr: AddressAnalysis,
        cb: F,
    ) -> Option<E::VirtualAddress>
    where F: FnOnce(&mut Self) -> Option<E::VirtualAddress>
    {
        let result = self.address_results[addr as usize];
        if result != E::VirtualAddress::from_u64(0) {
            if result == E::VirtualAddress::from_u64(1) {
                return None;
            } else {
                return Some(result);
            }
        }
        self.address_results[addr as usize] = E::VirtualAddress::from_u64(1);
        let result = cb(self);
        if let Some(result) = result {
            self.address_results[addr as usize] = result;
        }
        result
    }

    fn cache_single_operand<F>(&mut self, op: OperandAnalysis, cb: F) -> Option<Operand<'e>>
    where F: FnOnce(&mut Self) -> Option<Operand<'e>>
    {
        if let Some(result) = self.operand_results[op as usize] {
            if result == self.operand_not_found {
                return None;
            } else {
                return Some(result);
            }
        }
        self.operand_results[op as usize] = Some(self.operand_not_found);
        let result = cb(self);
        if result.is_some() {
            self.operand_results[op as usize] = result;
        }
        result
    }

    fn cache_many<F, const ADDR_COUNT: usize, const OPERAND_COUNT: usize>(
        &mut self,
        addresses: &[AddressAnalysis; ADDR_COUNT],
        operands: &[OperandAnalysis; OPERAND_COUNT],
        func: F,
    )
    where F: FnOnce(&mut AnalysisCache<'e, E>) ->
        Option<([Option<E::VirtualAddress>; ADDR_COUNT], [Option<Operand<'e>>; OPERAND_COUNT])>
    {
        for &addr in addresses {
            self.address_results[addr as usize] = E::VirtualAddress::from_u64(1);
        }
        for &op in operands {
            self.operand_results[op as usize] = Some(self.operand_not_found);
        }
        let result = func(self);
        if let Some(ref res) = result {
            for i in 0..ADDR_COUNT {
                if let Some(addr) = res.0[i] {
                    self.address_results[addresses[i] as usize] = addr;
                }
            }
            for i in 0..OPERAND_COUNT {
                if let Some(op) = res.1[i] {
                    self.operand_results[operands[i] as usize] = Some(op);
                }
            }
        }
    }

    fn cache_many_addr<F>(
        &mut self,
        addr: AddressAnalysis,
        cache_fn: F,
    ) -> Option<E::VirtualAddress>
    where F: FnOnce(&mut AnalysisCache<'e, E>)
    {
        if self.address_results[addr as usize] == E::VirtualAddress::from_u64(0) {
            cache_fn(self);
        }
        Some(self.address_results[addr as usize])
            .filter(|&addr| addr != E::VirtualAddress::from_u64(1))
    }

    fn cache_many_op<F>(&mut self, op: OperandAnalysis, cache_fn: F) -> Option<Operand<'e>>
    where F: FnOnce(&mut AnalysisCache<'e, E>)
    {
        if self.operand_results[op as usize].is_none() {
            cache_fn(self);
        }
        self.operand_results[op as usize]
            .filter(|&op| op != self.operand_not_found)
    }

    pub fn firegraft_addresses(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Rc<FiregraftAddresses<E::VirtualAddress>> {
        if let Some(cached) = self.firegraft_addresses.cached() {
            return cached;
        }
        let functions = &self.function_finder();
        let relocs = functions.globals_with_values();
        let buttonsets = firegraft::find_buttonsets(actx);
        let status_funcs = firegraft::find_unit_status_funcs(actx, &functions);
        let reqs = firegraft::find_requirement_tables(actx, &functions, relocs);
        let result = Rc::new(FiregraftAddresses {
            buttonsets,
            requirement_table_refs: reqs,
            unit_status_funcs: status_funcs,
        });
        self.firegraft_addresses.cache(&result);
        result
    }

    /// Returns address and dat table struct size
    pub fn dat_virtual_address(
        &mut self,
        ty: DatType,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<(E::VirtualAddress, u32)> {
        let dat = self.dat(ty, actx);
        let result = dat.iter()
            .filter_map(|x| x.address.if_constant().map(|y| (y, x.entry_size)))
            .next()
            .map(|(addr, size)| (E::VirtualAddress::from_u64(addr), size));
        result
    }

    pub fn dat(&mut self, ty: DatType, actx: &AnalysisCtx<'e, E>) -> Option<DatTablePtr<'e>> {
        let filename = {
            let (field, filename) = self.dat_tables.field(ty);
            if let Some(ref f) = *field {
                return f.clone();
            }
            filename
        };
        let result = dat::dat_table(actx, filename, &self.function_finder());
        let (field, _) = self.dat_tables.field(ty);
        *field = Some(result.clone());
        result
    }

    fn open_file(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::OpenFile, |s| {
            file::open_file(actx, &s.function_finder())
        })
    }

    fn cache_rng(&mut self, actx: &AnalysisCtx<'e, E>) {
        self.cache_many(&[], &[OperandAnalysis::RngSeed, OperandAnalysis::RngEnable], |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let rng = rng::rng(actx, units_dat, &s.function_finder());
            Some(([], [rng.seed, rng.enable]))
        })
    }

    pub fn rng_enable(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::RngEnable, |s| s.cache_rng(actx))
    }

    fn step_objects(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::StepObjects, |s| {
            game::step_objects(actx, s.rng_enable(actx)?, &s.function_finder())
        })
    }

    pub fn game(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::Game, |s| {
            game::game(actx, s.step_objects(actx)?)
        })
    }

    fn aiscript_hook(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<AiScriptHook<'e, E::VirtualAddress>> {
        self.ai_spend_money(actx);
        self.aiscript_hook
    }

    fn aiscript_switch_table(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        Some(self.aiscript_hook(actx)?.switch_table)
    }

    fn cache_regions(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[GetRegion, ChangeAiRegionState], &[OperandAnalysis::AiRegions], |s| {
            let aiscript_hook = s.aiscript_hook(actx);
            let result = pathing::regions(actx, aiscript_hook.as_ref()?);
            Some(([result.get_region, result.change_ai_region_state], [result.ai_regions]))
        })
    }

    #[cfg(feature = "test_assertions")]
    fn change_ai_region_state(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::ChangeAiRegionState, |s| s.cache_regions(actx))
    }

    fn get_region(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::GetRegion, |s| s.cache_regions(actx))
    }

    fn ai_regions(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::AiRegions, |s| s.cache_regions(actx))
    }

    fn pathing(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::Pathing, |s| {
            let get_region = s.get_region(actx)?;
            pathing::pathing(actx, get_region)
        })
    }

    fn cache_active_hidden_units(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[FirstActiveUnit, FirstHiddenUnit], |s| {
            let orders_dat = s.dat_virtual_address(DatType::Orders, actx)?;
            let functions = s.function_finder();
            let result = units::active_hidden_units(actx, orders_dat, &functions);
            Some(([], [result.first_active_unit, result.first_hidden_unit]))
        })
    }

    fn first_active_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::FirstActiveUnit,
            |s| s.cache_active_hidden_units(actx),
        )
    }

    fn first_hidden_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::FirstHiddenUnit,
            |s| s.cache_active_hidden_units(actx),
        )
    }

    fn cache_order_issuing(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[OrderInitArbiter, PrepareIssueOrder, DoNextQueuedOrder], &[], |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let functions = s.function_finder();
            let result = units::order_issuing(actx, units_dat, &functions);
            Some(([result.order_init_arbiter, result.prepare_issue_order,
                result.do_next_queued_order], []))
        })
    }

    fn prepare_issue_order(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::PrepareIssueOrder, |s| s.cache_order_issuing(actx))
    }

    fn order_init_arbiter(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::OrderInitArbiter, |s| s.cache_order_issuing(actx))
    }

    pub fn process_commands_switch(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<CompleteSwitch<'e>> {
        if let Some(cached) = self.process_commands_switch.cached() {
            return cached;
        }
        let func = self.process_commands(actx)?;
        let result = commands::analyze_process_fn_switch(actx, func);
        self.process_commands_switch.cache(&result);
        result
    }

    pub fn process_lobby_commands_switch(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<CompleteSwitch<'e>> {
        if let Some(cached) = self.process_lobby_commands_switch.cached() {
            return cached;
        }
        let func = self.process_lobby_commands(actx)?;
        let result = commands::analyze_process_fn_switch(actx, func);
        self.process_lobby_commands_switch.cache(&result);
        result
    }

    pub fn command_user(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::CommandUser, |s| {
            let switch = s.process_commands_switch(actx)?;
            commands::command_user(actx, s.game(actx)?, &switch)
        })
    }

    fn command_lengths(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vec<u32>> {
        if let Some(cached) = self.command_lengths.cached() {
            return cached;
        }

        let result = commands::command_lengths(actx);
        let result = Rc::new(result);
        self.command_lengths.cache(&result);
        result
    }

    fn cache_selections(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[UniqueCommandUser, Selections], |s| {
            let switch = s.process_commands_switch(actx)?;
            let result = commands::selections(actx, &switch);
            Some(([], [result.unique_command_user, result.selections]))
        })
    }

    fn selections(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::Selections, |s| s.cache_selections(actx))
    }

    fn is_replay(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::IsReplay, |s| {
            let switch = s.process_commands_switch(actx)?;
            commands::is_replay(actx, &switch)
        })
    }

    fn send_command(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::SendCommand, |s| {
            commands::send_command(actx, &s.firegraft_addresses(actx))
        })
    }

    fn cache_print_text(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[PrintText, AddToReplayData], &[], |s| {
            let process_commands = s.process_commands(actx)?;
            let switch = s.process_commands_switch(actx)?;
            let result = commands::print_text(actx, process_commands, &switch);
            Some(([result.print_text, result.add_to_replay_data], []))
        })
    }

    fn cache_init_map(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[InitMapFromPath, MapInitChkCallbacks], &[], |s| {
            let result = game_init::init_map_from_path(actx, &s.function_finder())?;
            Some(([Some(result.init_map_from_path), Some(result.map_init_chk_callbacks)], []))
        })
    }

    fn init_map_from_path(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::InitMapFromPath, |s| s.cache_init_map(actx))
    }

    fn map_init_chk_callbacks(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::MapInitChkCallbacks, |s| s.cache_init_map(actx))
    }

    fn cache_choose_snp(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[ChooseSnp, GetLocales], &[], |s| {
            let vtables = s.vtables(actx);
            let mut r = game_init::choose_snp(actx, &s.function_finder(), &vtables);
            if r.choose_snp.is_none() {
                if crate::util::test_assertions() {
                    panic!("Expected to find choose_snp with first method");
                }
                r = game_init::choose_snp_fallback(actx, &s.function_finder());
            }
            Some(([r.choose_snp, r.get_locales], []))
        })
    }

    fn choose_snp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::ChooseSnp, |s| s.cache_choose_snp(actx))
    }

    fn renderer_vtables(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vec<E::VirtualAddress>> {
        if let Some(cached) = self.renderer_vtables.cached() {
            return cached;
        }
        let vtables = self.vtables(actx);
        let result = Rc::new(
            vtables.vtables_starting_with(b".?AVRenderer@@\0").map(|x| x.address).collect()
        );
        self.renderer_vtables.cache(&result);
        result
    }

    fn vtables(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vtables<'e, E::VirtualAddress>> {
        if let Some(cached) = self.vtables.cached() {
            return cached;
        }
        let relocs = self.relocs();
        let result = Rc::new(vtables::vtables(actx, &relocs));
        self.vtables.cache(&result);
        result
    }

    fn all_vtables(&mut self, actx: &AnalysisCtx<'e, E>) -> Vec<E::VirtualAddress> {
        let mut result = self.vtables(actx).all_vtables().iter()
            .map(|x| x.address)
            .collect::<Vec<_>>();
        result.sort_unstable();
        result.dedup();
        result
    }

    fn vtables_for_class(
        &mut self,
        name: &[u8],
        actx: &AnalysisCtx<'e, E>,
    ) -> Vec<E::VirtualAddress> {
        let vtables = self.vtables(actx);
        let mut result = vtables.vtables_starting_with(name)
            .map(|x| x.address)
            .collect::<Vec<_>>();
        result.sort_unstable();
        result.dedup();
        result
    }

    fn cache_single_player_start(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[SinglePlayerStart], &[
            LocalStormPlayerId, LocalUniquePlayerId, NetPlayerToGame, NetPlayerToUnique,
            GameData, Skins, PlayerSkins,
        ], |s| {
            let choose_snp = s.choose_snp(actx)?;
            let local_player_id = s.local_player_id(actx)?;
            let functions = s.function_finder();
            let result =
                game_init::single_player_start(actx, &functions, choose_snp, local_player_id);
            s.skins_size = result.skins_size as u16;
            Some(([result.single_player_start], [result.local_storm_player_id,
                result.local_unique_player_id, result.net_player_to_game,
                result.net_player_to_unique, result.game_data, result.skins,
                result.player_skins]))
        })
    }

    fn single_player_start(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::SinglePlayerStart,
            |s| s.cache_single_player_start(actx),
        )
    }

    fn local_storm_player_id(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::LocalStormPlayerId,
            |s| s.cache_single_player_start(actx),
        )
    }

    fn local_player_id(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::LocalPlayerId, |s| {
            players::local_player_id(actx, s.game_screen_rclick(actx)?)
        })
    }

    fn cache_game_screen_rclick(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[GameScreenRClick], &[OperandAnalysis::ClientSelection], |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let functions = s.function_finder();
            let result = clientside::game_screen_rclick(actx, units_dat, &functions);
            Some(([result.game_screen_rclick], [result.client_selection]))
        });
    }

    fn game_screen_rclick(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::GameScreenRClick,
            |s| s.cache_game_screen_rclick(actx),
        )
    }

    fn cache_select_map_entry(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[SelectMapEntry], &[OperandAnalysis::IsMultiplayer], |s| {
            let single_player_start = s.single_player_start(actx)?;
            let functions = s.function_finder();
            let result = game_init::select_map_entry(actx, single_player_start, &functions);
            Some(([result.select_map_entry], [result.is_multiplayer]))
        })
    }

    fn select_map_entry(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::SelectMapEntry, |s| s.cache_select_map_entry(actx))
    }

    fn is_multiplayer(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::IsMultiplayer, |s| s.cache_select_map_entry(actx))
    }

    fn load_images(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::LoadImages, |s| {
            game_init::load_images(actx, &s.function_finder())
        })
    }

    fn cache_images_loaded(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[InitRealTimeLighting], &[ImagesLoaded, AssetScale], |s| {
            let load_images = s.load_images(actx)?;
            let result = game_init::images_loaded(actx, load_images, &s.function_finder());
            Some(([result.init_real_time_lighting], [result.images_loaded, result.asset_scale]))
        })
    }

    fn local_player_name(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::LocalPlayerName, |s| {
            let vtables = s.vtables(actx);
            let relocs = s.relocs();
            game_init::local_player_name(actx, &relocs, &vtables)
        })
    }

    fn cache_step_network(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[ReceiveStormTurns, ProcessCommands, ProcessLobbyCommands], &[
            NetPlayerFlags, PlayerTurns, PlayerTurnsSize, NetworkReady, StormCommandUser,
        ], |s| {
            let step_network = s.step_network(actx)?;
            let result = commands::analyze_step_network(actx, step_network);
            Some(([result.receive_storm_turns, result.process_commands,
                result.process_lobby_commands], [result.net_player_flags, result.player_turns,
                result.player_turns_size, result.network_ready, result.storm_command_user]))
        })
    }

    fn cache_net_format_turn_rate(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[NetFormatTurnRate], &[NetUserLatency], |s| {
            let result = network::anaylze_net_format_turn_rate(actx, &s.function_finder());
            Some(([result.net_format_turn_rate], [result.net_user_latency]))
        })
    }

    fn net_user_latency(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::NetUserLatency, |s| s.cache_net_format_turn_rate(actx))
    }

    fn net_format_turn_rate(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::NetFormatTurnRate,
                             |s| s.cache_net_format_turn_rate(actx))
    }

    fn process_commands(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::ProcessCommands, |s| s.cache_step_network(actx))
    }

    fn process_lobby_commands(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::ProcessLobbyCommands,
            |s| s.cache_step_network(actx),
        )
    }

    fn init_game_network(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::InitGameNetwork, |s| {
            let local_storm_player_id = s.local_storm_player_id(actx)?;
            let vtables = s.vtables(actx);
            game_init::init_game_network(actx, local_storm_player_id, &vtables)
        })
    }

    fn snp_definitions(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<SnpDefinitions<'e>> {
        if let Some(cached) = self.snp_definitions.cached() {
            return cached;
        }
        let result = network::snp_definitions(actx);
        self.snp_definitions.cache(&result);
        result
    }

    fn lobby_state(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::LobbyState, |s| {
            let switch = s.process_lobby_commands_switch(actx)?;
            game_init::lobby_state(actx, &switch)
        })
    }

    fn cache_init_storm_networking(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[InitStormNetworking, LoadSnpList], &[], |s| {
            let vtables = s.vtables(actx);
            let funcs = s.function_finder();
            let result = network::init_storm_networking(actx, &vtables, &funcs);
            Some(([result.init_storm_networking, result.load_snp_list], []))
        })
    }

    fn step_order(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::StepOrder, |s| {
            let order_init_arbiter = s.order_init_arbiter(actx)?;
            let funcs = s.function_finder();
            step_order::step_order(actx, order_init_arbiter, &funcs)
        })
    }

    fn order_function(
        &mut self,
        order: u8,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        let &cached = self.step_order_funcs.get(order as usize)?;
        let val = cached.as_u64();
        if val != 0 {
            if val == 1 {
                None
            } else {
                Some(cached)
            }
        } else {
            let func = match order {
                0x5 | 0x25 | 0x26 | 0x3f | 0x44 | 0x4e | 0x66 | 0x6d | 0x6e | 0x83 | 0x95 => 1u8,
                _ => 0,
            };
            self.step_order_funcs[order as usize] = E::VirtualAddress::from_u64(1);
            let result = if func == 0 {
                let step = self.step_order(actx)?;
                step_order::find_order_function(actx, step, order)?
            } else {
                if order == 5 {
                    let step = self.step_order_hidden(actx);
                    let step = step.get(0)?;
                    step_order::find_order_function_hidden(actx, step, order)?
                } else {
                    let step = self.step_secondary_order(actx);
                    let step = step.get(0)?;
                    step_order::find_order_function_secondary(actx, step, order)?
                }
            };
            self.step_order_funcs[order as usize] = result;
            Some(result)
        }
    }

    fn step_order_hidden(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Rc<Vec<step_order::StepOrderHiddenHook<'e, E::VirtualAddress>>> {
        if let Some(cached) = self.step_order_hidden.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let step_hidden = self.step_hidden_unit_frame(actx)?;
            Some(step_order::step_order_hidden(actx, step_hidden))
        }).unwrap_or_else(|| Vec::new());
        let result = Rc::new(result);
        self.step_order_hidden.cache(&result);
        result
    }

    fn step_secondary_order(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Rc<Vec<step_order::SecondaryOrderHook<'e, E::VirtualAddress>>> {
        if let Some(cached) = self.step_secondary_order.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let step_order = self.step_order(actx)?;
            Some(step_order::step_secondary_order(actx, step_order, &self.function_finder()))
        }).unwrap_or_else(|| Vec::new());
        let result = Rc::new(result);
        self.step_secondary_order.cache(&result);
        result
    }

    pub fn step_iscript(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::StepIscript, |s| {
            let finish_unit_pre = s.finish_unit_pre(actx)?;
            let sprite_size = s.sprite_array(actx)?.1;
            iscript::step_iscript(actx, finish_unit_pre, sprite_size)
        })
    }

    fn cache_step_iscript(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[StepIscriptSwitch], &[IscriptBin, FirstFreeImage, LastFreeImage], |s| {
            let step_iscript = s.step_iscript(actx)?;
            let result = iscript::analyze_step_iscript(actx, step_iscript);
            s.step_iscript_hook = result.hook;
            Some((
                [result.switch_table],
                [result.iscript_bin, result.first_free_image, result.last_free_image],
            ))
        })
    }

    pub fn step_iscript_switch(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepIscriptSwitch, |s| s.cache_step_iscript(actx))
    }

    fn add_overlay_iscript(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AddOverlayIscript, |s| {
            iscript::add_overlay_iscript(actx, s.step_iscript_switch(actx)?)
        })
    }

    fn draw_cursor_marker(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::DrawCursorMarker, |s| {
            iscript::draw_cursor_marker(actx, s.step_iscript_switch(actx)?)
        })
    }

    fn play_smk(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::PlaySmk, |s| {
            game_init::play_smk(actx, &s.function_finder())
        })
    }

    fn cache_game_init(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[ScMain, MainMenuEntryHook, GameLoop, RunMenus], &[ScMainState], |s| {
            let play_smk = s.play_smk(actx)?;
            let game = s.game(actx)?;
            let result = game_init::game_init(actx, play_smk, game, &s.function_finder());
            Some((
                [result.sc_main, result.mainmenu_entry_hook, result.game_loop, result.run_menus],
                [result.scmain_state],
            ))
        })
    }

    fn game_loop(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::GameLoop, |s| s.cache_game_init(actx))
    }

    fn run_menus(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::RunMenus, |s| s.cache_game_init(actx))
    }

    pub fn scmain_state(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::ScMainState, |s| s.cache_game_init(actx))
    }

    fn cache_misc_clientside(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[IsPaused, IsPlacingBuilding, IsTargeting], |s| {
            let is_multiplayer = s.is_multiplayer(actx)?;
            let scmain_state = s.scmain_state(actx)?;
            let vtables = s.vtables(actx);
            let funcs = s.function_finder();
            let result =
                clientside::misc_clientside(actx, is_multiplayer, scmain_state, &vtables, &funcs);
            Some(([], [result.is_paused, result.is_placing_building, result.is_targeting]))
        })
    }

    fn is_paused(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::IsPaused, |s| s.cache_misc_clientside(actx))
    }

    fn is_placing_building(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::IsPlacingBuilding, |s| s.cache_misc_clientside(actx))
    }

    fn is_targeting(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::IsTargeting, |s| s.cache_misc_clientside(actx))
    }

    fn cache_init_units(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[InitUnits, LoadDat], &[], |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let orders_dat = s.dat_virtual_address(DatType::Orders, actx)?;
            let funcs = s.function_finder();
            let result = units::init_units(actx, units_dat, orders_dat, &funcs);
            Some(([result.init_units, result.load_dat], []))
        })
    }

    pub fn init_units(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::InitUnits, |s| s.cache_init_units(actx))
    }

    pub fn load_dat(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::LoadDat, |s| s.cache_init_units(actx))
    }

    pub fn units(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::Units, |s| {
            units::units(actx, s.init_units(actx)?)
        })
    }

    pub fn first_guard_ai(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::FirstGuardAi, |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            ai::first_guard_ai(actx, units_dat, &s.function_finder())
        })
    }

    pub fn player_ai_towns(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::PlayerAiTowns, |s| {
            let aiscript_switch = s.aiscript_switch_table(actx)?;
            ai::player_ai_towns(actx, aiscript_switch)
        })
    }

    pub fn player_ai(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::PlayerAi, |s| {
            ai::player_ai(actx, s.aiscript_hook(actx).as_ref()?)
        })
    }

    fn cache_init_game(&mut self, actx: &AnalysisCtx<'e, E>) {
        self.cache_many(&[AddressAnalysis::InitGame], &[OperandAnalysis::LoadedSave], |s| {
            let init_units = s.init_units(actx)?;
            let result = game_init::init_game(actx, init_units, &s.function_finder());
            Some(([result.init_game], [result.loaded_save]))
        })
    }

    fn init_game(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::InitGame, |s| s.cache_init_game(actx))
    }

    fn loaded_save(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::LoadedSave, |s| s.cache_init_game(actx))
    }

    fn cache_sprites(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[AddressAnalysis::CreateLoneSprite], &[
            SpriteHlines, SpriteHlinesEnd, FirstFreeSprite, LastFreeSprite, FirstLoneSprite,
            LastLoneSprite, FirstFreeLoneSprite, LastFreeLoneSprite,
        ], |s| {
            let order_nuke_track = s.order_function(0x81, actx)?;
            let result = sprites::sprites(actx, order_nuke_track);
            s.sprite_x_position = result.sprite_x_position;
            s.sprite_y_position = result.sprite_y_position;
            Some(([result.create_lone_sprite], [
                result.sprite_hlines, result.sprite_hlines_end, result.first_free_sprite,
                result.last_free_sprite, result.first_lone, result.last_lone,
                result.first_free_lone, result.last_free_lone,
            ]))
        })
    }

    fn first_lone_sprite(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::FirstLoneSprite, |s| s.cache_sprites(actx))
    }

    fn first_free_sprite(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::FirstFreeSprite, |s| s.cache_sprites(actx))
    }

    fn last_free_sprite(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::LastFreeSprite, |s| s.cache_sprites(actx))
    }

    fn sprite_hlines_end(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::SpriteHlinesEnd, |s| s.cache_sprites(actx))
    }

    fn eud_table(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<EudTable<'e>> {
        if let Some(cached) = self.eud.cached() {
            return cached;
        }
        let result = eud::eud_table(actx, &self.function_finder());
        let result = Rc::new(result);
        self.eud.cache(&result);
        result
    }

    fn cache_map_tile_flags(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[UpdateVisibilityPoint], &[OperandAnalysis::MapTileFlags], |s| {
            let order_nuke_track = s.order_function(0x81, actx)?;
            let result = map::map_tile_flags(actx, order_nuke_track);
            Some(([result.update_visibility_point], [result.map_tile_flags]))
        })
    }

    fn cache_draw_game_layer(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[PrepareDrawImage, DrawImage, UpdateGameScreenSize, DrawTerrain],
            &[CursorMarker, ZoomActionActive, ZoomActionMode, ZoomActionStart, ZoomActionTarget,
                ZoomActionCompletion],
            |s| {
                let is_paused = s.is_paused(actx)?;
                let draw_game_layer = s.draw_game_layer(actx)?;
                let sprite_size = s.sprite_array(actx)?.1;
                let result = renderer::analyze_draw_game_layer(
                    actx,
                    draw_game_layer,
                    sprite_size,
                    is_paused,
                );
                Some(([result.prepare_draw_image, result.draw_image,
                    result.update_game_screen_size, result.draw_terrain], [result.cursor_marker,
                    result.zoom_action_active, result.zoom_action_mode,
                    result.zoom_action_start, result.zoom_action_target,
                    result.zoom_action_completion]))
            })
    }

    fn draw_terrain(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::DrawTerrain, |s| s.cache_draw_game_layer(actx))
    }

    fn draw_image(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::DrawImage, |s| s.cache_draw_game_layer(actx))
    }

    fn update_game_screen_size(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::UpdateGameScreenSize,
            |s| s.cache_draw_game_layer(actx),
        )
    }

    fn cache_bullet_creation(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[AddressAnalysis::CreateBullet], &[
            FirstActiveBullet, LastActiveBullet, FirstFreeBullet, LastFreeBullet,
            ActiveIscriptUnit,
        ], |s| {
            let result = bullets::bullet_creation(actx, s.step_iscript_switch(actx)?);
            Some(([result.create_bullet], [result.first_active_bullet, result.last_active_bullet,
                result.first_free_bullet, result.last_free_bullet, result.active_iscript_unit]))
        })
    }

    fn active_iscript_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::ActiveIscriptUnit, |s| s.cache_bullet_creation(actx))
    }

    fn first_active_bullet(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::FirstActiveBullet, |s| s.cache_bullet_creation(actx))
    }

    fn cache_net_players(&mut self, actx: &AnalysisCtx<'e, E>) {
        self.cache_many(&[AddressAnalysis::InitNetPlayer], &[OperandAnalysis::NetPlayers], |s| {
            let switch = s.process_lobby_commands_switch(actx)?;
            let result = players::net_players(actx, &switch);
            s.net_player_size = result.net_players.map(|x| x.1).unwrap_or(0) as u16;
            Some(([result.init_net_player], [result.net_players.map(|x| x.0)]))
        })
    }

    fn campaigns(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::Campaigns, |_| {
            campaign::campaigns(actx)
        })
    }

    fn cache_run_dialog(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[RunDialog, GluCmpgnEventHandler], &[], |s| {
            let result = dialog::run_dialog(actx, &s.function_finder());
            Some(([result.run_dialog, result.event_handler], []))
        })
    }

    fn run_dialog(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::RunDialog, |s| s.cache_run_dialog(actx))
    }

    fn glucmpgn_event_handler(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::GluCmpgnEventHandler, |s| s.cache_run_dialog(actx))
    }

    fn ai_update_attack_target(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AiUpdateAttackTarget, |s| {
            let order_computer_return = s.order_function(0xa3, actx)?;
            ai::ai_update_attack_target(actx, order_computer_return)
        })
    }

    fn is_outside_game_screen(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::IsOutsideGameScreen, |s| {
            let game_screen_rclick = s.game_screen_rclick(actx)?;
            clientside::is_outside_game_screen(actx, game_screen_rclick)
        })
    }

    fn cache_coord_conversion(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[ScreenX, ScreenY, Zoom], |s| {
            let game_screen_rclick = s.game_screen_rclick(actx)?;
            let is_outside_game_screen = s.is_outside_game_screen(actx)?;
            let result = clientside::game_coord_conversion(
                actx,
                game_screen_rclick,
                is_outside_game_screen
            );
            Some(([], [result.screen_x, result.screen_y, result.scale]))
        })
    }

    fn cache_fow_sprites(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[
            FirstFowSprite, LastFowSprite, FirstFreeFowSprite, LastFreeFowSprite,
        ], |s| {
            let step_objects = s.step_objects(actx)?;
            let first_lone = s.first_lone_sprite(actx)?;
            let result = sprites::fow_sprites(actx, step_objects, first_lone);
            Some(([], [
                result.first_active, result.last_active, result.first_free, result.last_free,
            ]))
        })
    }

    fn first_fow_sprite(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::FirstFowSprite, |s| s.cache_fow_sprites(actx))
    }

    fn first_free_fow_sprite(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::FirstFreeFowSprite, |s| s.cache_fow_sprites(actx))
    }

    fn cache_spawn_dialog(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[SpawnDialog, InitStatLb], &[], |s| {
            let result = dialog::spawn_dialog(actx, &s.function_finder());
            Some(([result.run_dialog, result.parent_function], []))
        })
    }

    fn spawn_dialog(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::SpawnDialog, |s| s.cache_spawn_dialog(actx))
    }

    fn init_statlb(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::InitStatLb, |s| s.cache_spawn_dialog(actx))
    }

    fn cache_init_statres(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[InitStatRes, GetStatResIconsDdsGrp], &[StatResIconsDdsGrp], |s| {
            let statres = dialog::init_statres(actx, &s.function_finder());
            let mut ddsgrp = None;
            let mut get_ddsgrp = None;
            if let Some(func) = statres.parent_function {
                let result = dialog::analyze_init_statres(actx, func);
                ddsgrp = result.statres_icons_ddsgrp;
                get_ddsgrp = result.get_statres_icons_ddsgrp;
            }
            Some(([statres.parent_function, get_ddsgrp], [ddsgrp]))
        })
    }

    fn cache_unit_creation(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[CreateUnit, FinishUnitPre, FinishUnitPost], &[], |s| {
            let order_scan = s.order_function(0x8b, actx)?;
            let result = units::unit_creation(actx, order_scan);
            Some(([result.create_unit, result.finish_unit_pre, result.finish_unit_post], []))
        })
    }

    fn finish_unit_pre(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::FinishUnitPre, |s| s.cache_unit_creation(actx))
    }

    fn finish_unit_post(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::FinishUnitPost, |s| s.cache_unit_creation(actx))
    }

    fn fonts(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::Fonts, |s| {
            text::fonts(actx, &s.function_finder())
        })
    }

    fn cache_init_sprites(&mut self, actx: &AnalysisCtx<'e, E>) {
        self.cache_many(&[AddressAnalysis::InitSprites], &[OperandAnalysis::Sprites], |s| {
            let first_free = s.first_free_sprite(actx)?;
            let last_free = s.last_free_sprite(actx)?;
            let functions = s.function_finder();
            let result = sprites::init_sprites(actx, first_free, last_free, &functions);
            s.sprite_struct_size = result.sprites.map(|x| x.1 as u16).unwrap_or(0);
            Some(([result.init_sprites], [result.sprites.map(|x| x.0)]))
        })
    }

    fn init_sprites(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::InitSprites, |s| s.cache_init_sprites(actx))
    }

    fn sprite_array(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<(Operand<'e>, u32)> {
        self.cache_many_op(OperandAnalysis::Sprites, |s| s.cache_init_sprites(actx))
            .map(|x| (x, self.sprite_struct_size.into()))
    }

    fn cache_sprite_serialization(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[SerializeSprites, DeserializeSprites], &[], |s| {
            let hlines_end = s.sprite_hlines_end(actx)?;
            let sprite_array = s.sprite_array(actx)?;
            let init_sprites = s.init_sprites(actx)?;
            let game = s.game(actx)?;
            let funcs = s.function_finder();
            let result = save::sprite_serialization(
                actx,
                hlines_end,
                sprite_array,
                init_sprites,
                game,
                &funcs,
            );
            Some(([result.serialize_sprites, result.deserialize_sprites], []))
        })
    }

    fn deserialize_sprites(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::DeserializeSprites,
            |s| s.cache_sprite_serialization(actx),
        )
    }

    fn limits(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Limits<'e, E::VirtualAddress>> {
        if let Some(cached) = self.limits.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let game_loop = self.game_loop(actx)?;
            Some(game::limits(actx, game_loop))
        }).unwrap_or_else(|| {
            Limits {
                set_limits: None,
                arrays: Vec::new(),
                smem_alloc: None,
                smem_free: None,
                allocator: None,
            }
        });
        let result = Rc::new(result);
        self.limits.cache(&result);
        result
    }

    fn cache_font_render(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[FontCacheRenderAscii, TtfCacheCharacter, TtfRenderSdf], &[], |s| {
            let result = text::font_render(actx, s.fonts(actx)?, &s.function_finder());
            Some(([
                result.font_cache_render_ascii, result.ttf_cache_character, result.ttf_render_sdf
            ], []))
        })
    }

    fn ttf_render_sdf(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::TtfRenderSdf, |s| s.cache_font_render(actx))
    }

    fn ttf_malloc(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::TtfMalloc, |s| {
            text::ttf_malloc(actx, s.ttf_render_sdf(actx)?)
        })
    }

    fn cache_select_map_entry_children(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[CreateGameMultiplayer, MapEntryLoadMap, MapEntryLoadReplay, MapEntryLoadSave],
            &[],
            |s| {
                let select_map_entry = s.select_map_entry(actx)?;
                let result = game_init::analyze_select_map_entry(actx, select_map_entry);
                s.create_game_dialog_vtbl_on_multiplayer_create =
                    result.create_game_dialog_vtbl_on_multiplayer_create;
                Some(([result.create_game_multiplayer, result.mde_load_map,
                        result.mde_load_replay, result.mde_load_save], []))
            },
        );
    }

    fn cache_tooltip_related(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[LayoutDrawText, DrawF10MenuTooltip, DrawTooltipLayer],
            &[TooltipDrawFunc, CurrentTooltipCtrl, GraphicLayers],
            |s| {
                let spawn_dialog = s.spawn_dialog(actx)?;
                let result = dialog::tooltip_related(actx, spawn_dialog, &s.function_finder());
                Some((
                    [result.layout_draw_text, result.draw_f10_menu_tooltip,
                    result.draw_tooltip_layer], [result.tooltip_draw_func,
                    result.current_tooltip_ctrl, result.graphic_layers],
                ))
            })
    }

    fn graphic_layers(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::GraphicLayers, |s| s.cache_tooltip_related(actx))
    }

    fn draw_graphic_layers(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::DrawGraphicLayers, |s| {
            dialog::draw_graphic_layers(actx, s.graphic_layers(actx)?, &s.function_finder())
        })
    }

    fn prism_shaders(&mut self, actx: &AnalysisCtx<'e, E>) -> PrismShaders<E::VirtualAddress> {
        if let Some(cached) = self.prism_shaders.cached() {
            return cached;
        }
        let vtables = self.vtables(actx);
        let result = renderer::prism_shaders(actx, &vtables);
        self.prism_shaders.cache(&result);
        result
    }

    fn prism_vertex_shaders(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vec<E::VirtualAddress>> {
        self.prism_shaders(actx).vertex_shaders
    }

    fn prism_pixel_shaders(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vec<E::VirtualAddress>> {
        self.prism_shaders(actx).pixel_shaders
    }

    fn cache_aiscript_switch(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AiAttackPrepare, AiAttackClear], &[],
            |s| {
                let aiscript_switch = s.aiscript_switch_table(actx)?;
                let r = ai::aiscript_switch_analysis(actx, aiscript_switch);
                Some(([r.ai_attack_prepare, r.ai_attack_clear], []))
            },
        )
    }

    fn cache_ai_step_frame(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[AiStepRegion, AiSpendMoney, StepAiScript, StepAiScripts, AiTargetExpansion],
            &[FirstAiScript, Players, StepAiRegionsRegion, StepAiRegionsPlayer, ResourceAreas,
                AiTargetIgnoreResetCounter, AiTargetIgnoreResetCounter2,
                AiTargetIgnoreRequestReset, AiMilitaryUpdateCounter],
            |s| {
                let step_objects = s.step_objects(actx)?;
                let game = s.game(actx)?;
                let result = ai::step_frame_funcs(actx, step_objects, game);
                s.aiscript_hook = result.hook;
                Some(([result.ai_step_region, result.ai_spend_money, result.step_ai_script,
                    result.step_ai_scripts, result.ai_target_expansion],
                    [result.first_ai_script, result.players, result.step_ai_regions_region,
                    result.step_ai_regions_player, result.resource_areas,
                    result.ai_target_ignore_reset_counter, result.ai_target_ignore_reset_counter2,
                    result.ai_target_ignore_request_reset, result.ai_military_update_counter]))
            },
        )
    }

    pub fn ai_step_region(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::AiStepRegion, |s| s.cache_ai_step_frame(actx))
    }

    pub fn ai_spend_money(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::AiSpendMoney, |s| s.cache_ai_step_frame(actx))
    }

    pub fn step_ai_script(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepAiScript, |s| s.cache_ai_step_frame(actx))
    }

    pub fn join_game(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::JoinGame, |s| {
            let local_storm_id = s.local_storm_player_id(actx)?;
            game_init::join_game(actx, local_storm_id, &s.function_finder())
        })
    }

    fn snet_initialize_provider(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::SnetInitializeProvider, |s| {
            game_init::snet_initialize_provider(actx, s.choose_snp(actx)?)
        })
    }

    fn set_status_screen_tooltip(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.dat_patches(actx)?.set_status_screen_tooltip
    }

    fn unit_wireframe_type(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Operand<'e>> {
        self.dat_patches(actx)?.unit_wireframe_type
    }

    fn campaign_map_names(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Operand<'e>> {
        self.dat_patches(actx)?.campaign_map_names.map(|x| x.0)
    }

    fn dat_patches(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Rc<DatPatches<'e, E::VirtualAddress>>> {
        if let Some(cached) = self.dat_patches.cached() {
            return cached;
        }
        let result = dat::dat_patches(self, actx).map(|x| Rc::new(x));
        self.dat_patches.cache(&result);
        result
    }

    fn cache_do_attack(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[DoAttack, DoAttackMain, AiTryReturnHome, UpdateAttackTarget],
            &[LastBulletSpawner],
            |s| {
                let attack_order = s.order_function(0xa, actx)?;
                let result = step_order::do_attack(actx, attack_order);
                Some(([result.do_attack, result.do_attack_main, result.ai_try_return_home,
                    result.update_attack_target],
                    [result.last_bullet_spawner]))
            })
    }

    fn smem_alloc(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.limits(actx).smem_alloc
    }

    fn smem_free(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.limits(actx).smem_free
    }

    fn allocator(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.limits(actx).allocator
    }

    fn cache_cmdicons(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[CmdIconsDdsGrp, CmdBtnsDdsGrp], |s| {
            let firegraft = s.firegraft_addresses(actx);
            let &status_arr = firegraft.unit_status_funcs.get(0)?;
            let result = dialog::button_ddsgrps(actx, status_arr);
            Some(([], [result.cmdicons, result.cmdbtns]))
        })
    }

    fn cache_mouse_xy(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[GetMouseX, GetMouseY], &[MouseX, MouseY], |s| {
            let run_dialog = s.run_dialog(actx)?;
            let result = dialog::mouse_xy(actx, run_dialog);
            Some(([result.x_func, result.y_func], [result.x_var, result.y_var]))
        })
    }

    fn status_screen_mode(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::StatusScreenMode, |s| {
            let firegraft = s.firegraft_addresses(actx);
            let &status_arr = firegraft.unit_status_funcs.get(0)?;
            dialog::status_screen_mode(actx, status_arr)
        })
    }

    fn cache_unit_requirements(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[CheckUnitRequirements], &[DatRequirementError], |s| {
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let funcs = s.function_finder();
            let result = requirements::check_unit_requirements(actx, units_dat, &funcs)?;
            Some(([Some(result.check_unit_requirements)], [Some(result.requirement_error)]))
        })
    }

    fn check_dat_requirements(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::CheckDatRequirements, |s| {
            let techdata = s.dat_virtual_address(DatType::TechData, actx)?;
            let functions = s.function_finder();
            requirements::check_dat_requirements(actx, techdata, &functions)
        })
    }

    fn cheat_flags(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::CheatFlags, |s| {
            requirements::cheat_flags(actx, s.check_dat_requirements(actx)?)
        })
    }

    fn cache_unit_strength_etc(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[InitGameBeforeMapLoadHook, CreateStartingUnits, CreateTeamGameStartingUnits],
            &[UnitStrength, SpriteIncludeInVisionSync, TeamGameTeams],
            |s| {
                let init_game = s.init_game(actx)?;
                let init_units = s.init_units(actx)?;
                let loaded_save = s.loaded_save(actx)?;
                let is_multiplayer = s.is_multiplayer(actx)?;
                let result =
                    units::strength(actx, init_game, init_units, loaded_save, is_multiplayer);
                Some((
                    [result.init_game_before_map_load_hook, result.create_starting_units,
                        result.create_team_game_starting_units],
                    [result.unit_strength, result.sprite_include_in_vision_sync,
                        result.team_game_teams],
                ))
            })
    }

    pub fn unit_strength(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::UnitStrength, |s| s.cache_unit_strength_etc(actx))
    }

    pub fn sprite_include_in_vision_sync(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::SpriteIncludeInVisionSync,
            |s| s.cache_unit_strength_etc(actx),
        )
    }

    /// Smaller size wireframes, that is multiselection and transport
    /// (Fits multiple in status screen)
    /// Also relevant mostly for SD, HD always uses wirefram.ddsgrp for the drawing.
    fn cache_multi_wireframes(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[InitStatusScreen, StatusScreenEventHandler],
            &[GrpWireGrp, GrpWireDdsGrp, TranWireGrp, TranWireDdsGrp, StatusScreen],
            |s| {
                let spawn_dialog = s.spawn_dialog(actx)?;
                let result = dialog::multi_wireframes(actx, spawn_dialog, &s.function_finder());
                Some((
                    [result.init_status_screen, result.status_screen_event_handler],
                    [result.grpwire_grp, result.grpwire_ddsgrp, result.tranwire_grp,
                    result.tranwire_ddsgrp, result.status_screen]
                ))
            })
    }

    pub fn grpwire_grp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::GrpWireGrp, |s| s.cache_multi_wireframes(actx))
    }

    pub fn grpwire_ddsgrp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::GrpWireDdsGrp, |s| s.cache_multi_wireframes(actx))
    }

    pub fn tranwire_grp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::TranWireGrp, |s| s.cache_multi_wireframes(actx))
    }

    pub fn tranwire_ddsgrp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::TranWireDdsGrp, |s| s.cache_multi_wireframes(actx))
    }

    pub fn status_screen(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(OperandAnalysis::StatusScreen, |s| s.cache_multi_wireframes(actx))
    }

    pub fn status_screen_event_handler(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::StatusScreenEventHandler,
            |s| s.cache_multi_wireframes(actx),
        )
    }

    pub fn wirefram_ddsgrp(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::WireframDdsgrp, |s| {
            dialog::wirefram_ddsgrp(actx, s.status_screen_event_handler(actx)?)
        })
    }

    pub fn init_status_screen(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::InitStatusScreen,
            |s| s.cache_multi_wireframes(actx),
        )
    }

    fn run_triggers(&mut self, actx: &AnalysisCtx<'e, E>) -> RunTriggers<E::VirtualAddress> {
        if let Some(cached) = self.run_triggers.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let rng_enable = self.rng_enable(actx)?;
            let step_objects = self.step_objects(actx)?;
            Some(map::run_triggers(actx, rng_enable, step_objects, &self.function_finder()))
        }).unwrap_or_else(|| RunTriggers::default());
        self.run_triggers.cache(&result);
        result
    }

    pub fn trigger_conditions(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.run_triggers(actx).conditions
    }

    pub fn trigger_actions(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.run_triggers(actx).actions
    }

    pub fn trigger_unit_count_caches(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> TriggerUnitCountCaches<'e> {
        if let Some(cached) = self.trigger_unit_count_caches.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let conditions = self.trigger_conditions(actx)?;
            let game = self.game(actx)?;
            Some(map::trigger_unit_count_caches(actx, conditions, game))
        }).unwrap_or_else(|| Default::default());
        self.trigger_unit_count_caches.cache(&result);
        result
    }

    pub fn trigger_completed_units_cache(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Operand<'e>> {
        self.trigger_unit_count_caches(actx).completed_units
    }

    pub fn trigger_all_units_cache(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.trigger_unit_count_caches(actx).all_units
    }

    fn cache_snet_handle_packets(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[SnetSendPackets, SnetRecvPackets], &[], |s| {
            let vtables = s.vtables(actx);
            let result = network::snet_handle_packets(actx, &vtables);
            Some(([result.send_packets, result.recv_packets], []))
        })
    }

    fn chk_init_players(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::ChkInitPlayers, |s| {
            let chk_callbacks = s.map_init_chk_callbacks(actx)?;
            game_init::chk_init_players(actx, chk_callbacks)
        })
    }

    fn original_chk_player_types(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::OriginalChkPlayerTypes, |s| {
            let init_players = s.chk_init_players(actx)?;
            game_init::original_chk_player_types(actx, init_players, &s.function_finder())
        })
    }

    fn give_ai(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::GiveAi, |s| {
            let actions = s.trigger_actions(actx)?;
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            ai::give_ai(actx, actions, units_dat)
        })
    }

    fn play_sound(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::PlaySound, |s| {
            sound::play_sound(actx, s.step_iscript_switch(actx)?)
        })
    }

    fn do_missile_damage(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::DoMissileDamage, |s| {
            bullets::do_missile_damage(actx, s.step_iscript_switch(actx)?)
        })
    }

    fn ai_prepare_moving_to(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AiPrepareMovingTo, |s| {
            let order_move = s.order_function(0x6, actx)?;
            ai::ai_prepare_moving_to(actx, order_move)
        })
    }

    fn ai_transport_reachability_cached_region(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::AiTransportReachabilityCachedRegion, |s| {
            let prepare_moving = s.ai_prepare_moving_to(actx)?;
            ai::ai_transport_reachability_cached_region(actx, prepare_moving)
        })
    }

    fn cache_draw_image(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[GetUnitSkin], &[PlayerUnitSkins], |s| {
            let result = renderer::analyze_draw_image(actx, s.draw_image(actx)?);
            Some(([result.get_unit_skin], [result.player_unit_skins]))
        })
    }

    fn replay_minimap_unexplored_fog_patch(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Rc<Patch<E::VirtualAddress>>> {
        if let Some(cached) = self.replay_minimap_unexplored_fog_patch.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let first_fow_sprite = self.first_fow_sprite(actx)?;
            let is_replay = self.is_replay(actx)?;
            let funcs = self.function_finder();
            Some(minimap::unexplored_fog_minimap_patch(actx, first_fow_sprite, is_replay, &funcs))
        });
        let (patch, draw_minimap_units) = match result {
            Some(s) => (s.0.map(Rc::new), s.1),
            None => (None, None),
        };
        self.replay_minimap_unexplored_fog_patch.cache(&patch);
        self.cache_single_address(AddressAnalysis::DrawMinimapUnits, |_| draw_minimap_units);
        patch
    }

    fn draw_minimap_units(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        if self.address_results[AddressAnalysis::DrawMinimapUnits as usize] ==
            E::VirtualAddress::from_u64(0)
        {
            self.replay_minimap_unexplored_fog_patch(actx);
        }
        self.cache_single_address(AddressAnalysis::DrawMinimapUnits, |_| None)
    }

    fn deserialize_lone_sprite_patch(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<Rc<Patch<E::VirtualAddress>>> {
        if let Some(cached) = self.deserialize_lone_sprite_patch.cached() {
            return cached;
        }
        let result = Some(()).and_then(|()| {
            let deserialize_sprites = self.deserialize_sprites(actx)?;
            let funcs = self.function_finder();
            save::deserialize_lone_sprite_patch(actx, deserialize_sprites, &funcs)
        });
        let patch = result.map(Rc::new);
        self.deserialize_lone_sprite_patch.cache(&patch);
        patch
    }

    fn step_replay_commands(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::StepReplayCommands, |s| {
            let process_commands = s.process_commands(actx)?;
            let game = s.game(actx)?;
            commands::step_replay_commands(actx, process_commands, game, &s.function_finder())
        })
    }

    fn replay_data(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::ReplayData, |s| {
            let switch = &s.process_commands_switch(actx)?;
            commands::replay_data(actx, &switch)
        })
    }

    fn ai_train_military(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AiTrainMilitary, |s| {
            ai::train_military(actx, s.ai_spend_money(actx)?, s.game(actx)?)
        })
    }

    fn ai_add_military_to_region(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AiAddMilitaryToRegion, |s| {
            let train_military = s.ai_train_military(actx)?;
            ai::add_military_to_region(actx, train_military, s.ai_regions(actx)?)
        })
    }

    fn vertex_buffer(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_single_operand(OperandAnalysis::VertexBuffer, |s| {
            let vtables = s.vtables(actx);
            renderer::vertex_buffer(actx, &vtables)
        })
    }

    fn crt_fastfail(&mut self, actx: &AnalysisCtx<'e, E>) -> Rc<Vec<E::VirtualAddress>> {
        if let Some(cached) = self.crt_fastfail.cached() {
            return cached;
        }
        let result = Rc::new(crt::fastfail(actx));
        self.crt_fastfail.cache(&result);
        result
    }

    fn cache_ui_event_handlers(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[ResetUiEventHandlers, UiDefaultScrollHandler, TargetingLClick, TargetingRClick,
                BuildingPlacementLClick, BuildingPlacementRClick, GameScreenLClick,
                UiDefaultKeyDownHandler, UiDefaultKeyUpHandler, UiDefaultLeftDownHandler,
                UiDefaultRightDownHandler,
                UiDefaultMiddleDownHandler, UiDefaultMiddleUpHandler, UiDefaultPeriodicHandler,
                UiDefaultCharHandler],
            &[GlobalEventHandlers, GameScreenLClickCallback, GameScreenRClickCallback],
            |s| {
                let game_screen_rclick = s.game_screen_rclick(actx)?;
                let is_targeting = s.is_targeting(actx)?;
                let is_placing_building = s.is_placing_building(actx)?;
                let result = dialog::ui_event_handlers(
                    actx,
                    game_screen_rclick,
                    is_targeting,
                    is_placing_building,
                    &s.function_finder(),
                );
                Some((
                    [result.reset_ui_event_handlers, result.default_scroll_handler,
                        result.targeting_lclick, result.targeting_rclick,
                        result.building_placement_lclick, result.building_placement_rclick,
                        result.game_screen_l_click, result.default_key_down_handler,
                        result.default_key_up_handler, result.default_left_down_handler,
                        result.default_right_down_handler,
                        result.default_middle_down_handler, result.default_middle_up_handler,
                        result.default_periodic_handler, result.default_char_handler],
                    [result.global_event_handlers, result.game_screen_lclick_callback,
                        result.game_screen_rclick_callback],
                ))
            });
    }

    fn ui_default_scroll_handler(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::UiDefaultScrollHandler,
            |s| s.cache_ui_event_handlers(actx),
        )
    }

    fn reset_ui_event_handlers(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::ResetUiEventHandlers,
            |s| s.cache_ui_event_handlers(actx),
        )
    }

    fn game_screen_lclick(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::GameScreenLClick,
            |s| s.cache_ui_event_handlers(actx),
        )
    }

    fn global_event_handlers(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::GlobalEventHandlers,
            |s| s.cache_ui_event_handlers(actx),
        )
    }

    fn targeting_lclick(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::TargetingLClick,
            |s| s.cache_ui_event_handlers(actx),
        )
    }

    fn clamp_zoom(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::ClampZoom, |s| {
            let scroll_handler = s.ui_default_scroll_handler(actx)?;
            let is_multiplayer = s.is_multiplayer(actx)?;
            dialog::clamp_zoom(actx, scroll_handler, is_multiplayer)
        })
    }

    fn cache_replay_visions(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(&[], &[ReplayVisions, ReplayShowEntireMap, FirstPlayerUnit], |s| {
            let draw_minimap_units = s.draw_minimap_units(actx)?;
            let is_replay = s.is_replay(actx)?;
            let result = minimap::replay_visions(actx, draw_minimap_units, is_replay);
            Some(([], [
                result.replay_visions, result.replay_show_entire_map, result.first_player_unit,
            ]))
        })
    }

    fn cache_menu_screens(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[SetBriefingMusic, PreMissionGlue, ShowMissionGlue], &[], |s| {
            let run_menus = s.run_menus(actx)?;
            let result = dialog::analyze_run_menus(actx, run_menus);
            Some(([result.set_music, result.pre_mission_glue, result.show_mission_glue], []))
        })
    }

    fn cache_glucmpgn_events(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[MenuSwishIn, MenuSwishOut], &[DialogReturnCode], |s| {
            let event_handler = s.glucmpgn_event_handler(actx)?;
            let result = dialog::analyze_glucmpgn_events(actx, event_handler);
            Some(([result.swish_in, result.swish_out], [result.dialog_return_code]))
        })
    }

    fn ai_spell_cast(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::AiSpellCast, |s| {
            let order_guard = s.order_function(0xa0, actx)?;
            ai::ai_spell_cast(actx, order_guard)
        })
    }

    fn give_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::GiveUnit, |s| {
            let actions = s.trigger_actions(actx)?;
            units::give_unit(actx, actions)
        })
    }

    fn set_unit_player(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::SetUnitPlayer, |s| {
            let give_unit = s.give_unit(actx)?;
            units::set_unit_player(actx, give_unit)
        })
    }

    fn cache_set_unit_player_fns(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[
            RemoveFromSelections,
            RemoveFromClientSelection,
            ClearBuildQueue,
            UnitChangingPlayer,
            PlayerGainedUpgrade,
        ], &[], |s| {
            let set_unit_player = s.set_unit_player(actx)?;
            let selections = s.selections(actx)?;
            let result = units::analyze_set_unit_player(actx, set_unit_player, selections);
            Some(([
                result.remove_from_selections, result.remove_from_client_selection,
                result.clear_build_queue, result.unit_changing_player,
                result.player_gained_upgrade,
            ], []))
        })
    }

    fn unit_changing_player(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::UnitChangingPlayer,
            |s| s.cache_set_unit_player_fns(actx),
        )
    }

    fn cache_unit_speed(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(&[
            UnitApplySpeedUpgrades,
            UnitUpdateSpeed,
            UnitUpdateSpeedIscript,
            UnitBuffedFlingySpeed,
            UnitBuffedAcceleration,
            UnitBuffedTurnSpeed,
        ], &[], |s| {
            let unit_changing_player = s.unit_changing_player(actx)?;
            let step_iscript = s.step_iscript(actx)?;
            let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
            let flingy_dat = s.dat_virtual_address(DatType::Flingy, actx)?;
            let result = units::unit_apply_speed_upgrades(
                actx,
                units_dat,
                flingy_dat,
                unit_changing_player,
                step_iscript,
            );
            Some(([
                result.apply_speed_upgrades, result.update_speed, result.update_speed_iscript,
                result.buffed_flingy_speed, result.buffed_acceleration, result.buffed_turn_speed,
            ], []))
        })
    }

    fn start_udp_server(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::StartUdpServer, |s| {
            network::start_udp_server(actx, &s.function_finder())
        })
    }

    fn cache_image_loading(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[
            OpenAnimSingleFile, OpenAnimMultiFile, InitSkins,
            AddAssetChangeCallback, AnimAssetChangeCb,
        ], &[
            BaseAnimSet, ImageGrps, ImageOverlays, ShieldOverlays, FireOverlayMax,
        ], |s| {
            let load_images = s.load_images(actx)?;
            let load_dat = s.load_dat(actx)?;
            let images_dat = s.dat_virtual_address(DatType::Images, actx)?;
            let result = game_init::analyze_load_images(
                actx,
                load_images,
                load_dat,
                images_dat,
            );
            s.anim_struct_size = result.anim_struct_size;
            Some(([
                result.open_anim_single_file, result.open_anim_multi_file, result.init_skins,
                result.add_asset_change_cb, result.anim_asset_change_cb,
            ], [
                result.base_anim_set, result.image_grps,
                result.image_overlays, result.shield_overlays, result.fire_overlay_max,
            ]))
        })
    }

    fn cache_step_objects(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[
            StepActiveUnitFrame, StepHiddenUnitFrame, StepBulletFrame, RevealUnitArea,
            UpdateUnitVisibility, UpdateCloakState, StepBullets, CreepModifyState,
            ForEachSurroundingile, CreepUpdateBorderForTile, GetCreepSpreadArea,
        ], &[
            VisionUpdateCounter, VisionUpdated, FirstDyingUnit, FirstRevealer, FirstInvisibleUnit,
            ActiveIscriptFlingy, ActiveIscriptBullet, DcreepNextUpdate, DcreepListSize,
            DcreepListBegin, DcreepLookup, CreepFuncs, DcreepUnitNextUpdate, UnitCount,
            LastDyingUnit, FirstFreeUnit, LastFreeUnit, OrderTimerResetCounter,
            SecondaryOrderTimerResetCounter,
        ], |s| {
            let step_objects = s.step_objects(actx)?;
            let game = s.game(actx)?;
            let first_active_unit = s.first_active_unit(actx)?;
            let first_hidden_unit = s.first_hidden_unit(actx)?;
            let first_active_bullet = s.first_active_bullet(actx)?;
            let active_iscript_unit = s.active_iscript_unit(actx)?;
            let result = game::analyze_step_objects(
                actx,
                step_objects,
                game,
                first_active_unit,
                first_hidden_unit,
                first_active_bullet,
                active_iscript_unit,
            );
            Some(([
                result.step_active_frame, result.step_hidden_frame, result.step_bullet_frame,
                result.reveal_area, result.update_unit_visibility, result.update_cloak_state,
                result.step_bullets, result.creep_modify_state, result.for_each_surrounding_tile,
                result.creep_update_border_for_tile, result.get_creep_spread_area,
            ], [
                result.vision_update_counter, result.vision_updated, result.first_dying_unit,
                result.first_revealer, result.first_invisible_unit, result.active_iscript_flingy,
                result.active_iscript_bullet, result.dcreep_next_update, result.dcreep_list_size,
                result.dcreep_list_begin, result.dcreep_lookup, result.creep_funcs,
                result.dcreep_unit_next_update, result.unit_count, result.last_dying_unit,
                result.first_free_unit, result.last_free_unit, result.order_timer_reset_counter,
                result.secondary_order_timer_reset_counter,
            ]))
        })
    }

    #[cfg(feature = "test_assertions")]
    fn first_revealer(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::FirstRevealer,
            |s| s.cache_active_hidden_units(actx),
        )
    }

    fn step_active_unit_frame(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepActiveUnitFrame, |s| s.cache_step_objects(actx))
    }

    fn step_hidden_unit_frame(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepHiddenUnitFrame, |s| s.cache_step_objects(actx))
    }

    fn reveal_unit_area(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::RevealUnitArea, |s| s.cache_step_objects(actx))
    }

    fn step_bullet_frame(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepBulletFrame, |s| s.cache_step_objects(actx))
    }

    fn step_bullets(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepBullets, |s| s.cache_step_objects(actx))
    }

    fn update_unit_visibility(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::UpdateUnitVisibility,
            |s| s.cache_step_objects(actx),
        )
    }

    fn cache_step_active_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[StepUnitMovement], &[UnitShouldRevealArea], |s| {
            let step_active_unit = s.step_active_unit_frame(actx)?;
            let reveal_area = s.reveal_unit_area(actx)?;
            let result = units::analyze_step_active_unit(
                actx,
                step_active_unit,
                reveal_area
            );
            Some(([result.step_unit_movement], [result.should_vision_update]))
        })
    }

    fn draw_game_layer(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::DrawGameLayer, |s| {
            let draw_layers = s.graphic_layers(actx)?;
            renderer::draw_game_layer(actx, draw_layers, &s.function_finder())
        })
    }

    fn cache_game_loop(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[StepNetwork, RenderScreen, LoadPcx, SetMusic, StepGameLoop, ProcessEvents,
            StepGameLogic],
            &[MainPalette, PaletteSet, TfontGam, SyncActive, SyncData, MenuScreenId,
            ContinueGameLoop, AntiTroll, StepGameFrames, NextGameStepTick, ReplaySeekFrame],
            |s|
        {
            let game_loop = s.game_loop(actx)?;
            let game = s.game(actx)?;
            let result = game_init::analyze_game_loop(actx, game_loop, game);
            Some(([result.step_network, result.render_screen, result.load_pcx, result.set_music,
                result.step_game_loop, result.process_events, result.step_game_logic],
                [result.main_palette, result.palette_set, result.tfontgam, result.sync_active,
                result.sync_data, result.menu_screen_id, result.continue_game_loop,
                result.anti_troll, result.step_game_frames, result.next_game_step_tick,
                result.replay_seek_frame]))
        })
    }

    fn step_network(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::StepNetwork, |s| s.cache_game_loop(actx))
    }

    fn process_events(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::ProcessEvents, |s| s.cache_game_loop(actx))
    }

    fn render_screen(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::RenderScreen, |s| s.cache_game_loop(actx))
    }

    fn cache_prepare_issue_order(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[],
            &[FirstFreeOrder, LastFreeOrder, AllocatedOrderCount, ReplayBfix, ReplayGcfg],
            |s|
        {
            let prepare_issue_order = s.prepare_issue_order(actx)?;
            let result = units::analyze_prepare_issue_order(actx, prepare_issue_order);
            Some(([], [result.first_free_order, result.last_free_order,
                result.allocated_order_count, result.replay_bfix, result.replay_gcfg]))
        })
    }

    fn cache_process_events(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[StepBnetController],
            &[BnetController],
            |s|
        {
            let process_events = s.process_events(actx)?;
            let result = game_init::analyze_process_events(actx, process_events);
            s.bnet_message_switch = result.bnet_message_switch;
            s.bnet_message_vtable_type = result.message_vtable_type;
            Some(([result.step_bnet_controller], [result.bnet_controller]))
        })
    }

    fn join_param_variant_type_offset(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<usize> {
        if self.join_param_variant_type_offset == u16::MAX {
            self.join_param_variant_type_offset = 0xfffe;
            let join_game = self.join_game(actx)?;
            if let Some(result) = game_init::join_param_variant_type_offset(actx, join_game) {
                self.join_param_variant_type_offset = result;
            }
        }
        Some(self.join_param_variant_type_offset).filter(|&x| x < 0xfffe).map(|x| x as usize)
    }

    fn cache_pylon_aura(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[AddPylonAura], &[FirstPylon, PylonAurasVisible, PylonRefresh], |s| {
            let order_pylon_init = s.order_function(0xa4, actx)?;
            let result = units::pylon_aura(actx, order_pylon_init);
            Some((
                [result.add_pylon_aura],
                [result.first_pylon, result.pylon_auras_visible, result.pylon_refresh],
            ))
        })
    }

    fn cache_sp_map_end(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(&[SinglePlayerMapEnd], &[LocalGameResult], |s| {
            let is_multiplayer = s.is_multiplayer(actx)?;
            let run_dialog = s.run_dialog(actx)?;
            let funcs = s.function_finder();
            let result =
                game_init::single_player_map_end(actx, is_multiplayer, run_dialog, &funcs);
            Some((
                [result.single_player_map_end],
                [result.local_game_result],
            ))
        })
    }

    fn single_player_map_end(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::SinglePlayerMapEnd, |s| s.cache_sp_map_end(actx))
    }

    fn cache_sp_map_end_analysis(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[SetScmainState, UnlockMission],
            &[IsCustomSinglePlayer, CurrentCampaignMission],
            |s|
        {
            let sp_map_end = s.single_player_map_end(actx)?;
            let result = game_init::single_player_map_end_analysis(actx, sp_map_end);
            Some((
                [result.set_scmain_state, result.unlock_mission],
                [result.is_custom_single_player, result.current_campaign_mission],
            ))
        })
    }

    fn cache_update_unit_visibility(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[CreateFowSprite, DuplicateSprite],
            &[LocalVisions, FirstFreeSelectionCircle, LastFreeSelectionCircle, UnitSkinMap,
            SpriteSkinMap],
            |s|
        {
            let update_unit_visibility = s.update_unit_visibility(actx)?;
            let units = s.units(actx)?;
            let sprites = s.sprite_array(actx)?.0;
            let first_free_fow = s.first_free_fow_sprite(actx)?;
            let result = units::update_unit_visibility_analysis(
                actx,
                update_unit_visibility,
                units,
                sprites,
                first_free_fow,
            );
            Some((
                [result.create_fow_sprite, result.duplicate_sprite],
                [result.local_visions, result.first_free_selection_circle,
                result.last_free_selection_circle, result.unit_skin_map, result.sprite_skin_map],
            ))
        })
    }

    fn first_free_selection_circle(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<Operand<'e>> {
        self.cache_many_op(
            OperandAnalysis::FirstFreeSelectionCircle,
            |s| s.cache_update_unit_visibility(actx),
        )
    }

    fn cache_init_map_from_path(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[LoadReplayScenarioChk, SfileCloseArchive, OpenMapMpq, ReadWholeMpqFile,
                ReadWholeMpqFile2],
            &[ReplayScenarioChk, ReplayScenarioChkSize, MapMpq, MapHistory],
            |s|
        {
            let init_map_from_path = s.init_map_from_path(actx)?;
            let is_replay = s.is_replay(actx)?;
            let game = s.game(actx)?;
            let result = game_init::init_map_from_path_analysis(
                actx,
                init_map_from_path,
                is_replay,
                game,
            );
            Some((
                [result.load_replay_scenario_chk, result.sfile_close_archive,
                    result.open_map_mpq, result.read_whole_mpq_file, result.read_whole_mpq_file2],
                [result.replay_scenario_chk, result.replay_scenario_chk_size, result.map_mpq,
                    result.map_history],
            ))
        })
    }

    fn read_whole_mpq_file(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::ReadWholeMpqFile2,
            |s| s.cache_init_map_from_path(actx),
        ).or_else(|| {
            self.cache_many_addr(
                AddressAnalysis::ReadWholeMpqFile,
                |s| s.cache_init_map_from_path(actx),
            )
        })
    }

    fn cache_start_targeting(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[StartTargeting],
            &[TargetedOrderUnit, TargetedOrderGround, TargetedOrderFow, MinimapCursorType],
            |s| {
                let firegraft = s.firegraft_addresses(actx);
                let buttonsets = *firegraft.buttonsets.get(0)?;
                let result = clientside::start_targeting(actx, buttonsets);
                Some((
                    [result.start_targeting],
                    [result.targeted_order_unit, result.targeted_order_ground,
                        result.targeted_order_fow, result.minimap_cursor_type],
                ))
            });
    }

    fn cache_targeting_lclick(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[FindUnitForClick, FindFowSpriteForClick, HandleTargetedClick],
            &[],
            |s| {
                let lclick = s.targeting_lclick(actx)?;
                let result = clientside::analyze_targeting_lclick(actx, lclick);
                Some((
                    [result.find_unit_for_click, result.find_fow_sprite_for_click,
                        result.handle_targeted_click],
                    [],
                ))
            });
    }

    fn handle_targeted_click(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::HandleTargetedClick,
            |s| s.cache_targeting_lclick(actx),
        )
    }

    fn cache_handle_targeted_click(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[CheckWeaponTargetingFlags, CheckTechTargeting, CheckOrderTargeting,
                CheckFowOrderTargeting],
            &[],
            |s| {
                let click = s.handle_targeted_click(actx)?;
                let orders_dat = s.dat_virtual_address(DatType::Orders, actx)?;
                let result = clientside::analyze_handle_targeted_click(actx, click, orders_dat);
                Some((
                    [result.check_weapon_targeting_flags, result.check_tech_targeting,
                        result.check_order_targeting, result.check_fow_order_targeting],
                    [],
                ))
            });
    }

    fn cache_step_order(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AiFocusDisabled, AiFocusAir],
            &[],
            |s| {
                let step_order = s.step_order(actx)?;
                let result = step_order::step_order_analysis(actx, step_order);
                Some((
                    [result.ai_focus_disabled, result.ai_focus_air],
                    [],
                ))
            });
    }

    fn cache_open_file(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[FileExists],
            &[],
            |s| {
                let open_file = s.open_file(actx)?;
                let result = file::open_file_analysis(actx, open_file);
                Some((
                    [result.file_exists],
                    [],
                ))
            });
    }

    fn cache_order_train(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[StepTrain, AddAiToTrainedUnit, CancelQueuedUnit, RefreshUi],
            &[],
            |s| {
                let train = s.order_function(0x26, actx)?;
                let result = step_order::analyze_order_train(actx, train);
                Some((
                    [result.step_train, result.add_ai_to_trained_unit, result.cancel_queued_unit,
                        result.refresh_ui],
                    [],
                ))
            });
    }

    fn add_ai_to_trained_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::AddAiToTrainedUnit, |s| s.cache_order_train(actx))
    }

    fn cache_order_matrix(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[GetSightRange],
            &[],
            |s| {
                let matrix = s.order_function(0x8d, actx)?;
                let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
                let result = step_order::analyze_order_matrix(actx, matrix, units_dat);
                Some((
                    [result.get_sight_range],
                    [],
                ))
            });
    }

    fn cache_order_player_guard(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[GetTargetAcquisitionRange, PickAutoTarget, AttackUnit],
            &[],
            |s| {
                let guard = s.order_function(0x3, actx)?;
                let result = step_order::analyze_order_player_guard(actx, guard);
                Some((
                    [result.get_target_acquisition_range, result.pick_auto_target,
                        result.attack_unit],
                    [],
                ))
            });
    }

    fn get_target_acquisition_range(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::GetTargetAcquisitionRange,
            |s| s.cache_order_player_guard(actx),
        )
    }

    fn cache_order_arbiter_cloak(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[GetAttackRange, FindUnitBordersRect],
            &[],
            |s| {
                let cloak = s.order_function(0x83, actx)?;
                let units_dat = s.dat_virtual_address(DatType::Units, actx)?;
                let result = step_order::analyze_order_arbiter_cloak(actx, cloak, units_dat);
                Some((
                    [result.get_attack_range, result.find_unit_borders_rect],
                    [],
                ))
            });
    }

    fn cache_order_tower(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[PickRandomTarget],
            &[],
            |s| {
                let tower = s.order_function(0x12, actx)?;
                let get_acq = s.get_target_acquisition_range(actx)?;
                let result = step_order::analyze_order_tower(actx, tower, get_acq);
                Some((
                    [result.pick_random_target],
                    [],
                ))
            });
    }

    fn cache_order_infest(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[UnitCanBeInfested, UnitDetachAddon, UnitCanRally],
            &[],
            |s| {
                let infest = s.order_function(0xf, actx)?;
                let result = step_order::analyze_order_infest(actx, infest);
                Some((
                    [result.can_be_infested, result.detach_addon, result.can_rally],
                    [],
                ))
            });
    }

    fn cache_order_zerg_build_self(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[UnitSetHp, TransformUnit, StopCreepDisappearingAtBuilding, PlaceCreepRect],
            &[],
            |s| {
                let infest = s.order_function(0x2d, actx)?;
                let r = step_order::analyze_order_zerg_build_self(actx, infest);
                Some((
                    [r.unit_set_hp, r.transform_unit, r.stop_creep_disappearing_at_building,
                        r.place_creep_rect],
                    [],
                ))
            });
    }

    #[cfg(feature = "test_assertions")]
    fn transform_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::TransformUnit,
            |s| s.cache_order_zerg_build_self(actx),
        )
    }

    fn cache_order_nuke_launch(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[ShowUnit, HideUnit, MoveUnit, StopMoving],
            &[],
            |s| {
                let launch = s.order_function(0x7d, actx)?;
                let r = step_order::analyze_order_nuke_launch(actx, launch);
                Some((
                    [r.show_unit, r.hide_unit, r.move_unit, r.stop_moving],
                    [],
                ))
            });
    }

    fn hide_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::HideUnit, |s| s.cache_order_nuke_launch(actx))
    }

    fn cache_render_screen(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[ConfigVsyncValue, GetRenderTarget, ClearRenderTarget],
            &[Renderer, DrawCommands],
            |s| {
                let render = s.render_screen(actx)?;
                let result = renderer::analyze_render_screen(actx, render);
                Some((
                    [result.config_vsync_value, result.get_render_target,
                        result.clear_render_target],
                    [result.renderer, result.draw_commands],
                ))
            });
    }

    fn cache_center_view_action(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[MoveScreen],
            &[TriggerCurrentPlayer, GameScreenWidthBwpx, GameScreenHeightBwPx],
            |s| {
                let actions = s.trigger_actions(actx)?;
                let local_player_id = s.local_player_id(actx)?;
                let is_multiplayer = s.is_multiplayer(actx)?;
                let result = clientside::analyze_center_view_action(
                    actx,
                    actions,
                    local_player_id,
                    is_multiplayer,
                );
                Some((
                    [result.move_screen],
                    [result.trigger_current_player, result.game_screen_width_bwpx,
                        result.game_screen_height_bwpx],
                ))
            });
    }

    fn cache_step_bullet_frame(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[StepMovingBulletFrame],
            &[],
            |s| {
                let step_bullet_frame = s.step_bullet_frame(actx);
                let step_bullets = s.step_bullets(actx);
                let first_active_bullet = s.first_active_bullet(actx)?;
                let result = bullets::analyze_step_bullet_frame(
                    actx,
                    step_bullets,
                    step_bullet_frame,
                    first_active_bullet,
                );
                Some(([result.step_moving_bullet_frame], []))
            })
    }

    fn step_moving_bullet_frame(
        &mut self,
        actx: &AnalysisCtx<'e, E>,
    ) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::StepMovingBulletFrame,
            |s| s.cache_step_bullet_frame(actx),
        )
    }

    fn cache_step_moving_bullet_frame(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[FlingyUpdateTargetDir, StepFlingySpeed, StepFlingyMovementStartEnd,
                StepFlingyPosition, MoveSprite, StepFlingyTurning],
            &[FlingyFlagsTmp, FlingyXOld, FlingyYOld, FlingyXNew, FlingyYNew, FlingyExactXNew,
                FlingyExactYNew, FlingyFlagsNew, FlingyShowEndWalkAnim, FlingyShowStartWalkAnim,
                MapWidthPixels, MapHeightPixels, FlingySpeedUsedForMove],
            |s| {
                let step = s.step_moving_bullet_frame(actx)?;
                let r = bullets::analyze_step_moving_bullet_frame(actx, step);
                Some(([r.flingy_update_target_dir, r.step_flingy_speed,
                    r.step_flingy_movement_start_end, r.step_flingy_position, r.move_sprite,
                    r.step_flingy_turning], [r.flingy_flags_tmp, r.flingy_x_old, r.flingy_y_old,
                    r.flingy_x_new, r.flingy_y_new, r.flingy_exact_x_new, r.flingy_exact_y_new,
                    r.flingy_flags_new, r.flingy_show_end_walk_anim, r.flingy_show_start_walk_anim,
                    r.map_width_pixels, r.map_height_pixels, r.flingy_speed_used_for_move]))
            })
    }

    fn cache_do_missile_damage(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[HitUnit, UnitWasHit, DisableUnit, AiUnitWasHit, LookupSoundId, PlaySoundAtUnit,
                KillUnit, UnitMaxEnergy, SplashLurker, SplashFull, ForEachUnitInArea],
            &[],
            |s| {
                let do_dmg = s.do_missile_damage(actx)?;
                let r = bullets::analyze_do_missile_damage(actx, do_dmg);
                Some(([r.hit_unit, r.unit_was_hit, r.disable_unit, r.ai_unit_was_hit,
                    r.lookup_sound_id, r.play_sound_at_unit, r.kill_unit, r.unit_max_energy,
                    r.splash_lurker, r.splash_full, r.for_each_unit_in_area],
                    []))
            })
    }

    fn kill_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::KillUnit, |s| s.cache_do_missile_damage(actx))
    }

    fn hit_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::HitUnit, |s| s.cache_do_missile_damage(actx))
    }

    fn splash_lurker(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::SplashLurker, |s| s.cache_do_missile_damage(actx))
    }

    fn cache_hit_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[HallucinationHit, DoWeaponDamage],
            &[],
            |s| {
                let hit = s.hit_unit(actx)?;
                let r = bullets::analyze_hit_unit(actx, hit);
                Some(([r.hallucination_hit, r.do_weapon_damage], []))
            })
    }

    fn do_weapon_damage(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::DoWeaponDamage, |s| s.cache_hit_unit(actx))
    }

    fn cache_do_weapon_damage(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[DamageUnit, ShowShieldOverlayForDirection, ShowShieldOverlay, UnitUpdateStrength,
                UnitCalculateStrength],
            &[],
            |s| {
                let do_dmg = s.do_weapon_damage(actx)?;
                let r = bullets::analyze_do_weapon_damage(actx, do_dmg);
                Some(([r.damage_unit, r.show_shield_overlay_for_direction, r.show_shield_overlay,
                    r.unit_update_strength, r.unit_calculate_strength], []))
            })
    }

    fn cache_step_replay_commands(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[ReplayEnd],
            &[ReplayHeader],
            |s| {
                let do_dmg = s.step_replay_commands(actx)?;
                let r = commands::analyze_step_replay_commands(actx, do_dmg);
                Some(([r.replay_end], [r.replay_header]))
            })
    }

    fn cache_read_mpq_file(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[SFileOpenFileEx, SFileReadFileEx, SFileCloseFile],
            &[MpqLocale],
            |s| {
                let read = s.read_whole_mpq_file(actx)?;
                let r = storm::analyze_read_whole_mpq_file(actx, read);
                Some(([r.sfile_open_file_ex, r.sfile_read_file_ex, r.sfile_close_file],
                    [r.mpq_locale]))
            })
    }

    fn cache_init_ingame_ui(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[InitIngameUi, InitObsUi, LoadConsoles, InitConsoles, GetUiConsoles],
            &[UiConsoles, ObserverUi],
            |s| {
                let init_statlb = s.init_statlb(actx)?;
                let is_replay = s.is_replay(actx)?;
                let funcs = s.function_finder();
                let r = clientside::init_ingame_ui(actx, &funcs, init_statlb, is_replay);
                Some(([r.init_ingame_ui, r.init_obs_ui, r.load_consoles, r.init_consoles,
                    r.get_ui_consoles],
                    [r.ui_consoles, r.observer_ui]))
            })
    }

    fn cache_player_colors(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[],
            &[UseRgbColors, RgbColors, DisableColorChoice, UseMapSetRgbColor, GameLobby,
                InLobbyOrGame],
            |s| {
                let switch = &s.process_lobby_commands_switch(actx)?;
                let r = commands::player_colors(actx, &switch);
                Some(([], [r.use_rgb, r.rgb_colors, r.disable_choice, r.use_map_set_rgb,
                    r.game_lobby, r.in_lobby_or_game]))
            })
    }

    fn cache_game_screen_lclick(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[StopTargeting, PlaceBuilding, SelectMouseUp, SelectMouseMove, ClipCursor],
            &[GameScreenRectWinPx, OnClipCursorEnd, SelectStartX, SelectStartY, IsSelecting],
            |s| {
                let lclick = s.game_screen_lclick(actx)?;
                let is_targeting = s.is_targeting(actx)?;
                let is_placing_building = s.is_placing_building(actx)?;
                let global_event_handlers = s.global_event_handlers(actx)?;
                let r = clientside::analyze_game_screen_lclick(
                    actx,
                    is_targeting,
                    is_placing_building,
                    global_event_handlers,
                    lclick,
                );
                Some(([r.stop_targeting, r.place_building, r.select_mouse_up, r.select_mouse_move,
                    r.clip_cursor], [r.game_screen_rect_winpx, r.on_clip_cursor_end,
                    r.select_start_x, r.select_start_y, r.is_selecting]))
            })
    }

    fn select_mouse_up(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::SelectMouseUp, |s| s.cache_game_screen_lclick(actx))
    }

    fn cache_select_mouse_up(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[DecideCursorType, SetCurrentCursorType, SelectUnits], &[],
            |s| {
                let mouse_up = s.select_mouse_up(actx)?;
                let reset_ui_event_handlers = s.reset_ui_event_handlers(actx)?;
                let r = clientside::analyze_select_mouse_up(
                    actx,
                    reset_ui_event_handlers,
                    mouse_up,
                );
                Some(([r.decide_cursor_type, r.set_current_cursor_type, r.select_units], []))
            })
    }

    fn cache_run_dialog_children(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[CtrlSetTimer], &[FirstDialog, RunDialogStack],
            |s| {
                let run_dialog = s.run_dialog(actx)?;
                let r = dialog::analyze_run_dialog(actx, run_dialog);
                Some(([r.ctrl_set_timer], [r.first_dialog, r.run_dialog_stack]))
            })
    }

    fn cache_update_game_screen_size(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[], &[UpdateGameScreenSizeMode, GameScreenHeightRatio],
            |s| {
                let update = s.update_game_screen_size(actx)?;
                let r = clientside::analyze_update_game_screen_size(actx, update);
                Some(([], [r.update_mode, r.game_screen_height_ratio]))
            })
    }

    fn cache_play_sound(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[], &[SfxData, SoundChannels],
            |s| {
                let play = s.play_sound(actx)?;
                let r = sound::analyze_play_sound(actx, play);
                Some(([], [r.sfx_data, r.sound_channels]))
            })
    }

    fn cache_finish_unit_post(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[], &[LastHiddenUnit, LastRevealer],
            |s| {
                let func = s.finish_unit_post(actx)?;
                let r = units::analyze_finish_unit_post(actx, func);
                #[cfg(feature = "test_assertions")]
                {
                    let first_hidden = s.first_hidden_unit(actx);
                    assert_eq!(r.first_hidden_unit, first_hidden);
                    let first_revealer = s.first_revealer(actx);
                    assert_eq!(r.first_revealer, first_revealer);
                }
                Some(([], [r.last_hidden_unit, r.last_revealer]))
            })
    }

    fn cache_splash_lurker(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[], &[LurkerHits, LurkerHitsFrame, LurkerHitsPos],
            |s| {
                let func = s.splash_lurker(actx)?;
                let r = bullets::analyze_splash_lurker(actx, func);
                Some(([], [r.lurker_hits, r.lurker_hits_frame, r.lurker_hits_pos]))
            })
    }

    fn cache_hide_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[RemoveReferences, EndCollisionTracking], &[LastActiveUnit, PathArray, FirstFreePath],
            |s| {
                let func = s.hide_unit(actx)?;
                let r = units::analyze_hide_unit(actx, func);
                #[cfg(feature = "test_assertions")]
                {
                    let first_active = s.first_active_unit(actx);
                    assert_eq!(r.first_active_unit, first_active);
                }
                Some(([r.remove_references, r.end_collision_tracking],
                    [r.last_active_unit, r.path_array, r.first_free_path]))
            })
    }

    fn cache_kill_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[DropPowerup, AiRemoveUnit], &[],
            |s| {
                let func = s.kill_unit(actx)?;
                let r = units::analyze_kill_unit(actx, func);
                Some(([r.drop_powerup, r.remove_unit_ai], []))
            })
    }

    fn ai_remove_unit(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(AddressAnalysis::AiRemoveUnit, |s| s.cache_kill_unit(actx))
    }

    fn file_read_fatal_error(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_single_address(AddressAnalysis::FileReadFatalError, |s| {
            let load_dat = s.load_dat(actx)?;
            file::read_fatal_error(actx, load_dat)
        })
    }

    fn cache_ai_remove_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AiRemoveUnitMilitary, AiRemoveUnitTown], &[],
            |s| {
                let func = s.ai_remove_unit(actx)?;
                let r = ai::analyze_ai_remove_unit(actx, func);
                Some(([r.military, r.town], []))
            })
    }

    fn cache_add_ai_to_trained_unit(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AddBuildingAi, AddMilitaryAi], &[],
            |s| {
                let func = s.add_ai_to_trained_unit(actx)?;
                let r = ai::analyze_add_ai_to_trained_unit(actx, func);
                #[cfg(feature = "test_assertions")]
                {
                    let change_ai_region_state = s.change_ai_region_state(actx);
                    assert_eq!(r.change_ai_region_state, change_ai_region_state);
                }
                Some(([r.add_building_ai, r.add_military_ai], []))
            })
    }

    fn add_building_ai(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::AddBuildingAi,
            |s| s.cache_add_ai_to_trained_unit(actx),
        )
    }

    fn cache_add_building_ai(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AddTownUnitAi], &[],
            |s| {
                let func = s.add_building_ai(actx)?;
                let r = ai::analyze_add_building_ai(actx, func);
                Some(([r.add_town_unit_ai], []))
            })
    }

    fn cache_init_images(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[InitImages],
            &[Images, HpBarImages, HpBarState, SelectionCircles, PlacementImages, PlacementRects,
                FirstFreeHpBar, LastFreeHpBar, FirstFreePlacementImage, LastFreePlacementImage,
                FirstFreePlacementRect, LastFreePlacementRect],
            |s| {
                let circle = s.first_free_selection_circle(actx)?;
                let funcs = s.function_finder();
                let r = images::init_images(actx, circle, &funcs);
                Some(([r.init_images], [r.images, r.hp_bar_images, r.hp_bar_state,
                    r.selection_circles, r.placement_images, r.placement_rects,
                    r.first_free_hp_bar, r.last_free_hp_bar,
                    r.first_free_placement_image, r.last_free_placement_image,
                    r.first_free_placement_rect, r.last_free_placement_rect,
                ]))
            })
    }

    fn init_images(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::InitImages,
            |s| s.cache_init_images(actx),
        )
    }

    fn cache_init_terrain(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        use OperandAnalysis::*;
        self.cache_many(
            &[InitTerrain],
            &[TilesetIndexedMapTiles, Vx4MapTiles, TerrainFramebuf, RepulseState,
                TilesetData, TileDefaultFlags, TilesetCv5, TilesetVx4Ex,
                MinitileGraphics, MinitileData, FoliageState],
            |s| {
                let init_game = s.init_game(actx)?;
                let init_images = s.init_images(actx)?;
                let r = map::init_terrain(actx, init_game, init_images);
                Some(([r.init_terrain], [r.tileset_indexed_map_tiles, r.vx4_map_tiles,
                    r.terrain_framebuf, r.repulse_state, r.tileset_data, r.tile_default_flags,
                    r.tileset_cv5, r.tileset_vx4ex, r.minitile_graphics, r.minitile_data,
                    r.foliage_state,
                ]))
            })
    }

    fn cache_draw_terrain(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[GetAtlasPageCoordsForTerrainTile],
            &[],
            |s| {
                let draw_terrain = s.draw_terrain(actx)?;
                let is_paused = s.is_paused(actx)?;
                let r = renderer::analyze_draw_terrain(actx, draw_terrain, is_paused);
                Some(([r.get_atlas_page_coords_for_terrain_tile], []))
            })
    }

    fn cache_unit_morph(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[ShowFinishedUnitNotification, SwitchConstructionImage, CheckResourcesForBuilding],
            &[],
            |s| {
                let order = s.order_function(0x2a, actx)?;
                let r = units::analyze_order_unit_morph(actx, order);
                #[cfg(feature = "test_assertions")]
                {
                    let transform_unit = s.transform_unit(actx);
                    assert_eq!(r.transform_unit, transform_unit);
                    let add_ai_to_trained_unit = s.add_ai_to_trained_unit(actx);
                    assert_eq!(r.add_ai_to_trained_unit, add_ai_to_trained_unit);
                }
                Some(([r.show_finished_unit_notification, r.switch_construction_image,
                    r.check_resources_for_building], []))
            })
    }

    fn cache_ai_step_region(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[AiRegionUpdateStrength, AiRegionUpdateTarget, AiRegionAbandonIfOverwhelmed,
                AiRegionPickAttackTarget],
            &[],
            |s| {
                let ai_step_region = s.ai_step_region(actx)?;
                let r = ai::analyze_ai_step_region(actx, ai_step_region);
                #[cfg(feature = "test_assertions")]
                {
                    let change_ai_region_state = s.change_ai_region_state(actx);
                    assert_eq!(r.change_ai_region_state, change_ai_region_state);
                }
                Some(([r.ai_region_update_strength, r.ai_region_update_target,
                    r.ai_region_abandon_if_overwhelmed, r.ai_region_pick_attack_target], []))
            },
        )
    }

    fn cache_trigger_talking_portrait(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[TriggerTalkingPortrait, ShowPortrait], &[],
            |s| {
                let actions = s.trigger_actions(actx)?;
                let r = clientside::analyze_talking_portrait_action(actx, actions);
                Some((
                    [r.trigger_talking_portrait, r.show_portrait],
                    [],
                ))
            })
    }

    fn show_portrait(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::ShowPortrait,
            |s| s.cache_trigger_talking_portrait(actx),
        )
    }

    fn cache_show_portrait(&mut self, actx: &AnalysisCtx<'e, E>) {
        use OperandAnalysis::*;
        self.cache_many(
            &[], &[StatportVideos, StatportTalkingPortraitActive, StatportVideoId],
            |s| {
                let show_portrait = s.show_portrait(actx)?;
                let r = clientside::analyze_show_portrait(actx, show_portrait);
                Some((
                    [],
                    [r.videos, r.talking_active, r.video_id],
                ))
            })
    }

    fn cache_join_custom_game(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[JoinCustomGame, FindFileWithCrc], &[],
            |s| {
                let join_game = s.join_game(actx)?;
                let funcs = s.function_finder();
                let r = game_init::join_custom_game(actx, join_game, &funcs);
                Some((
                    [r.join_custom_game, r.find_file_with_crc],
                    [],
                ))
            })
    }

    fn find_file_with_crc(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::FindFileWithCrc,
            |s| s.cache_join_custom_game(actx),
        )
    }

    fn cache_step_lobby_network(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[StepLobbyNetwork, SendQueuedLobbyCommands], &[],
            |s| {
                let step_network = s.step_network(actx)?;
                let send_command = s.send_command(actx)?;
                let funcs = s.function_finder();
                let r = network::step_lobby_network(actx, step_network, send_command, &funcs);
                Some((
                    [r.step_lobby_network, r.send_queued_lobby_commands],
                    [],
                ))
            })
    }

    fn step_lobby_network(&mut self, actx: &AnalysisCtx<'e, E>) -> Option<E::VirtualAddress> {
        self.cache_many_addr(
            AddressAnalysis::StepLobbyNetwork,
            |s| s.cache_step_lobby_network(actx),
        )
    }

    fn cache_step_lobby_state(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[ProcessAsyncLobbyCommand, CommandLobbyMapP2p], &[],
            |s| {
                let step_lobby_network = s.step_lobby_network(actx)?;
                let funcs = s.function_finder();
                let r = network::step_lobby_state(actx, step_lobby_network, &funcs);
                Some((
                    [r.process_async_lobby_command, r.command_lobby_map_p2p],
                    [],
                ))
            })
    }

    fn cache_find_file_with_crc(&mut self, actx: &AnalysisCtx<'e, E>) {
        use AddressAnalysis::*;
        self.cache_many(
            &[ForFilesInDir, SimpleFileMatchCallback], &[],
            |s| {
                let find_file_with_crc = s.find_file_with_crc(actx)?;
                let r = game_init::analyze_find_file_with_crc(actx, find_file_with_crc);
                Some((
                    [r.for_files_in_dir, r.simple_file_match_callback],
                    [],
                ))
            })
    }
}

pub struct DatPatchesDebug<'e, Va: VirtualAddress> {
    pub warnings: Vec<(&'static str, u32, String)>,
    pub tables: fxhash::FxHashMap<DatType, DatTablePatchesDebug<Va>>,
    pub replaces: Vec<(Va, Vec<u8>)>,
    pub func_replaces: Vec<(Va, DatReplaceFunc)>,
    pub hooks: Vec<(Va, u8, Vec<u8>)>,
    pub two_step_hooks: Vec<(Va, Va, u8, Vec<u8>)>,
    pub ext_array_patches: Vec<(Va, Option<Va>, u8, u32, Operand<'e>)>,
    pub ext_array_args: Vec<(Va, Vec<(usize, u8)>)>,
    pub grp_index_hooks: Vec<Va>,
    pub grp_texture_hooks: Vec<(Va, u8, Operand<'e>, Operand<'e>, Operand<'e>, u8, u8)>,
    pub campaign_map_names: Option<(Operand<'e>, Va)>,
}

pub struct DatTablePatchesDebug<Va: VirtualAddress> {
    pub array_patches: Vec<Vec<(Va, i32, i32, u32)>>,
    pub entry_counts: Vec<Va>,
}

impl<Va: VirtualAddress> Default for DatTablePatchesDebug<Va> {
    fn default() -> Self {
        DatTablePatchesDebug {
            array_patches: Vec::new(),
            entry_counts: Vec::new(),
        }
    }
}
